This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: contracts/**/*.sol, test/**/*.sol
- Files matching these patterns are excluded: node_modules, lib, out, build, dist, .git, dashboard
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
contracts/
  core/
    PQValidator.sol
    PQWallet.sol
    PQWalletFactory.sol
  examples/
    OracleConsumerExample.sol
  interfaces/
    IPQValidator.sol
    IPQWallet.sol
  libraries/
    DilithiumVerifier.sol
    PQConstants.sol
    ZKVerifier.sol
  oracles/
    PythPriceOracle.sol
    QRNGOracle.sol
    ZKProofOracle.sol
  vault/
    PQVault4626.sol
    PQVault4626Demo.sol
    PQVault4626With83b.sol
    PQVault4626WithPricing.sol
    VestingManager.sol
  verifiers/
    Groth16VerifierReal.sol
  DilithiumVerifier.sol
test/
  DilithiumVerifier.t.sol
  PQVault4626.t.sol
  PQWallet.t.sol

================================================================
Files
================================================================

================
File: contracts/examples/OracleConsumerExample.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "../oracles/ZKProofOracle.sol";
import "../oracles/QRNGOracle.sol";

/**
 * @title OracleConsumerExample
 * @notice Example contract showing how to use ZKProofOracle and QRNGOracle
 * @dev Demonstrates both pay-per-use and subscription models
 */
contract OracleConsumerExample is IProofConsumer, IRandomnessConsumer {
    ZKProofOracle public zkOracle;
    QRNGOracle public qrngOracle;

    // Track requests
    mapping(bytes32 => bool) public proofRequests;
    mapping(bytes32 => bool) public randomnessRequests;

    // Results
    mapping(bytes32 => bytes) public proofResults;
    mapping(bytes32 => uint256) public randomResults;

    event ProofRequestSent(bytes32 indexed requestId);
    event ProofReceived(bytes32 indexed requestId, bool isValid);
    event RandomnessRequestSent(bytes32 indexed requestId);
    event RandomnessReceived(bytes32 indexed requestId, uint256 randomness);

    constructor(address _zkOracle, address _qrngOracle) {
        zkOracle = ZKProofOracle(_zkOracle);
        qrngOracle = QRNGOracle(_qrngOracle);
    }

    // ============ ZK Proof Usage Examples ============

    /**
     * @notice Request ZK proof verification (pay-per-use)
     * @param message The message that was signed
     * @param signature The Dilithium signature
     * @param publicKey The Dilithium public key
     */
    function requestProofVerification(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) external payable returns (bytes32 requestId) {
        // Forward payment to oracle
        requestId = zkOracle.requestProof{value: msg.value}(
            message,
            signature,
            publicKey
        );

        proofRequests[requestId] = true;
        emit ProofRequestSent(requestId);

        return requestId;
    }

    /**
     * @notice Request proof using subscription
     */
    function requestProofWithSub(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) external returns (bytes32 requestId) {
        requestId = zkOracle.requestProofWithSubscription(
            message,
            signature,
            publicKey
        );

        proofRequests[requestId] = true;
        emit ProofRequestSent(requestId);

        return requestId;
    }

    /**
     * @notice Callback from ZKProofOracle (implements IProofConsumer)
     */
    function handleProof(
        bytes32 requestId,
        bytes memory proof,
        uint256[3] memory publicSignals
    ) external override {
        require(msg.sender == address(zkOracle), "Only oracle");
        require(proofRequests[requestId], "Unknown request");

        proofResults[requestId] = proof;

        // publicSignals[2] is the is_valid flag (0 or 1)
        bool isValid = publicSignals[2] == 1;

        emit ProofReceived(requestId, isValid);

        // Your business logic here
        if (isValid) {
            // Signature is valid, proceed with action
        } else {
            // Signature is invalid, reject
        }
    }

    // ============ QRNG Usage Examples ============

    /**
     * @notice Request quantum random number
     * @param seed Optional user seed for additional entropy
     */
    function requestRandomNumber(bytes32 seed) external payable returns (bytes32 requestId) {
        requestId = qrngOracle.requestRandomness{value: msg.value}(seed);

        randomnessRequests[requestId] = true;
        emit RandomnessRequestSent(requestId);

        return requestId;
    }

    /**
     * @notice Request multiple random numbers (more efficient)
     */
    function requestMultipleRandom(uint256 count) external payable returns (bytes32[] memory requestIds) {
        bytes32 seed = keccak256(abi.encodePacked(block.timestamp, msg.sender));
        requestIds = qrngOracle.requestMultipleRandomness{value: msg.value}(count, seed);

        for (uint256 i = 0; i < requestIds.length; i++) {
            randomnessRequests[requestIds[i]] = true;
            emit RandomnessRequestSent(requestIds[i]);
        }

        return requestIds;
    }

    /**
     * @notice Callback from QRNGOracle (implements IRandomnessConsumer)
     */
    function handleRandomness(bytes32 requestId, uint256 randomness) external override {
        require(msg.sender == address(qrngOracle), "Only oracle");
        require(randomnessRequests[requestId], "Unknown request");

        randomResults[requestId] = randomness;
        emit RandomnessReceived(requestId, randomness);

        // Your business logic here
        // Example: Use randomness for lottery, NFT traits, game mechanics, etc.
    }

    // ============ Subscription Management ============

    /**
     * @notice Subscribe to ZK Proof Oracle for discounted rates
     */
    function subscribeToZKOracle() external payable {
        zkOracle.subscribe{value: msg.value}();
    }

    /**
     * @notice Subscribe to QRNG Oracle
     */
    function subscribeToQRNG() external payable {
        qrngOracle.subscribe{value: msg.value}();
    }

    // ============ View Functions ============

    function getProofResult(bytes32 requestId) external view returns (bytes memory) {
        return proofResults[requestId];
    }

    function getRandomResult(bytes32 requestId) external view returns (uint256) {
        return randomResults[requestId];
    }

    /**
     * @notice Get random number in a specific range
     * @param requestId The fulfilled request ID
     * @param min Minimum value (inclusive)
     * @param max Maximum value (inclusive)
     */
    function getRandomInRange(
        bytes32 requestId,
        uint256 min,
        uint256 max
    ) external view returns (uint256) {
        return qrngOracle.getRandomInRange(requestId, min, max);
    }

    // Allow contract to receive ETH
    receive() external payable {}
}

/**
 * USAGE EXAMPLE:
 *
 * // 1. Deploy consumer contract
 * OracleConsumerExample consumer = new OracleConsumerExample(zkOracleAddr, qrngOracleAddr);
 *
 * // 2a. Request ZK proof (pay-per-use)
 * bytes32 proofReqId = consumer.requestProofVerification{value: 0.001 ether}(msg, sig, pk);
 *
 * // 2b. Or subscribe first for discount
 * consumer.subscribeToZKOracle{value: 0.05 ether}(); // 50 proofs prepaid
 * bytes32 proofReqId = consumer.requestProofWithSub(msg, sig, pk);
 *
 * // 3. Wait for callback
 * // handleProof() will be called automatically by oracle
 *
 * // 4. Request quantum random number
 * bytes32 randReqId = consumer.requestRandomNumber{value: 0.0005 ether}(seed);
 *
 * // 5. Wait for callback
 * // handleRandomness() will be called automatically
 *
 * // 6. Use the random number
 * uint256 diceRoll = consumer.getRandomInRange(randReqId, 1, 6);
 */

================
File: contracts/interfaces/IPQWallet.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {PackedUserOperation} from "lib/account-abstraction/contracts/interfaces/PackedUserOperation.sol";

/// @title IPQWallet
/// @notice Interface for Post-Quantum secure ERC-4337 compatible wallet
interface IPQWallet {
    /// @notice Emitted when a transaction is executed
    event Executed(address indexed target, uint256 value, bytes data);

    /// @notice Emitted when PQ public key is updated
    event PQPublicKeyUpdated(bytes oldKey, bytes newKey);

    /// @notice Returns the post-quantum public key
    function getPQPublicKey() external view returns (bytes memory);

    /// @notice Returns the address of the PQ validator
    function validator() external view returns (address);

    /// @notice Execute a transaction from this wallet
    /// @param target The target contract address
    /// @param value The amount of ETH to send
    /// @param data The calldata to execute
    function execute(address target, uint256 value, bytes calldata data) external;

    /// @notice Execute a batch of transactions
    /// @param targets Array of target addresses
    /// @param values Array of ETH amounts
    /// @param data Array of calldata
    function executeBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata data
    ) external;

    /// @notice Validate a user operation signature
    /// @param userOp The user operation to validate
    /// @param userOpHash Hash of the user operation
    /// @param missingAccountFunds Amount of funds missing to pay for the operation
    /// @return validationData Validation result (0 = success)
    function validateUserOp(
        PackedUserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 missingAccountFunds
    ) external returns (uint256 validationData);
}

================
File: contracts/libraries/PQConstants.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/// @title PQConstants
/// @notice NIST-compliant parameter sizes for post-quantum cryptographic algorithms
/// @dev Based on NIST PQC standardization (2024): ML-DSA (Dilithium) and SLH-DSA (SPHINCS+)
library PQConstants {
    // ============ Dilithium (ML-DSA) Constants ============

    /// @notice Dilithium2 (ML-DSA-44) - NIST Security Level 2 (~128-bit)
    uint256 public constant DILITHIUM2_PUBLIC_KEY_SIZE = 1312;
    uint256 public constant DILITHIUM2_SIGNATURE_SIZE = 2420;

    /// @notice Dilithium3 (ML-DSA-65) - NIST Security Level 3 (~192-bit) [RECOMMENDED]
    uint256 public constant DILITHIUM3_PUBLIC_KEY_SIZE = 1952;
    uint256 public constant DILITHIUM3_SIGNATURE_SIZE = 3293;

    /// @notice Dilithium5 (ML-DSA-87) - NIST Security Level 5 (~256-bit)
    uint256 public constant DILITHIUM5_PUBLIC_KEY_SIZE = 2592;
    uint256 public constant DILITHIUM5_SIGNATURE_SIZE = 4595;

    // ============ SPHINCS+ (SLH-DSA) Constants ============

    /// @notice SPHINCS+-SHA2-128f - Fast variant, 128-bit security [RECOMMENDED for most use cases]
    uint256 public constant SPHINCS_SHA2_128F_PUBLIC_KEY_SIZE = 32;
    uint256 public constant SPHINCS_SHA2_128F_SIGNATURE_SIZE = 17088;

    /// @notice SPHINCS+-SHA2-128s - Small variant, 128-bit security
    uint256 public constant SPHINCS_SHA2_128S_PUBLIC_KEY_SIZE = 32;
    uint256 public constant SPHINCS_SHA2_128S_SIGNATURE_SIZE = 7856;

    /// @notice SPHINCS+-SHA2-192f - Fast variant, 192-bit security
    uint256 public constant SPHINCS_SHA2_192F_PUBLIC_KEY_SIZE = 48;
    uint256 public constant SPHINCS_SHA2_192F_SIGNATURE_SIZE = 35664;

    /// @notice SPHINCS+-SHA2-192s - Small variant, 192-bit security
    uint256 public constant SPHINCS_SHA2_192S_PUBLIC_KEY_SIZE = 48;
    uint256 public constant SPHINCS_SHA2_192S_SIGNATURE_SIZE = 16224;

    /// @notice SPHINCS+-SHA2-256f - Fast variant, 256-bit security
    uint256 public constant SPHINCS_SHA2_256F_PUBLIC_KEY_SIZE = 64;
    uint256 public constant SPHINCS_SHA2_256F_SIGNATURE_SIZE = 49856;

    /// @notice SPHINCS+-SHA2-256s - Small variant, 256-bit security
    uint256 public constant SPHINCS_SHA2_256S_PUBLIC_KEY_SIZE = 64;
    uint256 public constant SPHINCS_SHA2_256S_SIGNATURE_SIZE = 29792;

    // ============ Validation Functions ============

    /// @notice Check if a public key size is valid for any supported algorithm
    /// @param keySize The public key size in bytes
    /// @return True if the size matches a NIST-compliant parameter set
    function isValidPublicKeySize(uint256 keySize) internal pure returns (bool) {
        return keySize == DILITHIUM2_PUBLIC_KEY_SIZE ||
               keySize == DILITHIUM3_PUBLIC_KEY_SIZE ||
               keySize == DILITHIUM5_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_128F_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_128S_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_192F_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_192S_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_256F_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_256S_PUBLIC_KEY_SIZE;
    }

    /// @notice Check if a signature size is valid for any supported algorithm
    /// @param sigSize The signature size in bytes
    /// @return True if the size matches a NIST-compliant parameter set
    function isValidSignatureSize(uint256 sigSize) internal pure returns (bool) {
        return sigSize == DILITHIUM2_SIGNATURE_SIZE ||
               sigSize == DILITHIUM3_SIGNATURE_SIZE ||
               sigSize == DILITHIUM5_SIGNATURE_SIZE ||
               sigSize == SPHINCS_SHA2_128F_SIGNATURE_SIZE ||
               sigSize == SPHINCS_SHA2_128S_SIGNATURE_SIZE ||
               sigSize == SPHINCS_SHA2_192F_SIGNATURE_SIZE ||
               sigSize == SPHINCS_SHA2_192S_SIGNATURE_SIZE ||
               sigSize == SPHINCS_SHA2_256F_SIGNATURE_SIZE ||
               sigSize == SPHINCS_SHA2_256S_SIGNATURE_SIZE;
    }

    /// @notice Get the algorithm name from public key size
    /// @param keySize The public key size in bytes
    /// @return Algorithm name or "Unknown"
    function getAlgorithmName(uint256 keySize) internal pure returns (string memory) {
        if (keySize == DILITHIUM2_PUBLIC_KEY_SIZE) return "Dilithium2 (ML-DSA-44)";
        if (keySize == DILITHIUM3_PUBLIC_KEY_SIZE) return "Dilithium3 (ML-DSA-65)";
        if (keySize == DILITHIUM5_PUBLIC_KEY_SIZE) return "Dilithium5 (ML-DSA-87)";
        if (keySize == SPHINCS_SHA2_128F_PUBLIC_KEY_SIZE) return "SPHINCS+-SHA2-128f";
        if (keySize == SPHINCS_SHA2_128S_PUBLIC_KEY_SIZE) return "SPHINCS+-SHA2-128s";
        if (keySize == SPHINCS_SHA2_192F_PUBLIC_KEY_SIZE) return "SPHINCS+-SHA2-192f";
        if (keySize == SPHINCS_SHA2_192S_PUBLIC_KEY_SIZE) return "SPHINCS+-SHA2-192s";
        if (keySize == SPHINCS_SHA2_256F_PUBLIC_KEY_SIZE) return "SPHINCS+-SHA2-256f";
        if (keySize == SPHINCS_SHA2_256S_PUBLIC_KEY_SIZE) return "SPHINCS+-SHA2-256s";
        return "Unknown";
    }

    /// @notice Check if key size is Dilithium
    /// @param keySize The public key size in bytes
    /// @return True if it's a Dilithium variant
    function isDilithiumKey(uint256 keySize) internal pure returns (bool) {
        return keySize == DILITHIUM2_PUBLIC_KEY_SIZE ||
               keySize == DILITHIUM3_PUBLIC_KEY_SIZE ||
               keySize == DILITHIUM5_PUBLIC_KEY_SIZE;
    }

    /// @notice Check if key size is SPHINCS+
    /// @param keySize The public key size in bytes
    /// @return True if it's a SPHINCS+ variant
    function isSPHINCSKey(uint256 keySize) internal pure returns (bool) {
        return keySize == SPHINCS_SHA2_128F_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_128S_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_192F_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_192S_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_256F_PUBLIC_KEY_SIZE ||
               keySize == SPHINCS_SHA2_256S_PUBLIC_KEY_SIZE;
    }
}

================
File: contracts/oracles/PythPriceOracle.sol
================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "pyth-sdk-solidity/IPyth.sol";
import "pyth-sdk-solidity/PythStructs.sol";

/**
 * @title PythPriceOracle
 * @notice Integrates Pyth Network price feeds for real-time token valuation
 * @dev Used to price vesting tokens in USD and other currencies
 *
 * Prize Eligibility: Pyth Network Integration
 *
 * Features:
 * - Multi-token price support
 * - Configurable staleness checks
 * - USD value calculations for vesting
 * - Emergency pause mechanism
 */
contract PythPriceOracle is Ownable, ReentrancyGuard {
    IPyth public pyth;

    /// @notice Maximum age of price data in seconds (default: 60 seconds)
    uint256 public maxPriceAge = 60;

    /// @notice Minimum confidence ratio (basis points, 10000 = 100%)
    uint256 public minConfidenceBps = 100; // 1% max uncertainty

    /// @notice Emergency pause flag
    bool public paused;

    /// @notice Mapping of token addresses to Pyth price feed IDs
    mapping(address => bytes32) public tokenToPriceId;

    /// @notice Supported token list
    address[] public supportedTokens;

    // Events
    event PriceIdUpdated(address indexed token, bytes32 priceId);
    event MaxPriceAgeUpdated(uint256 oldAge, uint256 newAge);
    event MinConfidenceUpdated(uint256 oldBps, uint256 newBps);
    event PriceQueried(address indexed token, int64 price, uint64 timestamp);
    event Paused(address indexed by);
    event Unpaused(address indexed by);

    // Errors
    error OracleIsPaused();
    error PriceNotAvailable(address token);
    error PriceTooOld(uint256 age, uint256 maxAge);
    error PriceNotConfident(uint256 confidence, uint256 minRequired);
    error InvalidPriceId();
    error InvalidToken();
    error PriceIsNegative();

    /**
     * @notice Constructor
     * @param _pyth Address of Pyth contract on this chain
     * @param _owner Owner address
     */
    constructor(address _pyth, address _owner) Ownable(_owner) {
        require(_pyth != address(0), "Invalid Pyth address");
        pyth = IPyth(_pyth);
    }

    /**
     * @notice Register a token's Pyth price feed ID
     * @param token Token address
     * @param priceId Pyth price feed ID
     */
    function setPriceId(address token, bytes32 priceId) external onlyOwner {
        require(token != address(0), "Invalid token");
        require(priceId != bytes32(0), "Invalid price ID");

        // Add to supported tokens if new
        if (tokenToPriceId[token] == bytes32(0)) {
            supportedTokens.push(token);
        }

        tokenToPriceId[token] = priceId;
        emit PriceIdUpdated(token, priceId);
    }

    /**
     * @notice Update maximum price age
     * @param _maxAge New max age in seconds
     */
    function setMaxPriceAge(uint256 _maxAge) external onlyOwner {
        require(_maxAge > 0 && _maxAge <= 1 hours, "Invalid max age");
        uint256 oldAge = maxPriceAge;
        maxPriceAge = _maxAge;
        emit MaxPriceAgeUpdated(oldAge, _maxAge);
    }

    /**
     * @notice Update minimum confidence ratio
     * @param _minBps New minimum confidence in basis points
     */
    function setMinConfidence(uint256 _minBps) external onlyOwner {
        require(_minBps <= 1000, "Confidence too high"); // Max 10%
        uint256 oldBps = minConfidenceBps;
        minConfidenceBps = _minBps;
        emit MinConfidenceUpdated(oldBps, _minBps);
    }

    /**
     * @notice Pause oracle in emergency
     */
    function pause() external onlyOwner {
        paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @notice Unpause oracle
     */
    function unpause() external onlyOwner {
        paused = false;
        emit Unpaused(msg.sender);
    }

    /**
     * @notice Get latest price for a token
     * @param token Token address
     * @return price Price with 8 decimals (Pyth standard)
     * @return expo Price exponent (always -8 for USD prices)
     * @return timestamp Price update time
     */
    function getPrice(address token)
        external
        view
        returns (int64 price, int32 expo, uint256 timestamp)
    {
        if (paused) revert OracleIsPaused();

        bytes32 priceId = tokenToPriceId[token];
        if (priceId == bytes32(0)) revert PriceNotAvailable(token);

        PythStructs.Price memory pythPrice = pyth.getPriceUnsafe(priceId);

        // Validate price
        _validatePrice(pythPrice);

        return (pythPrice.price, pythPrice.expo, pythPrice.publishTime);
    }

    /**
     * @notice Get USD value of token amount
     * @param token Token address
     * @param amount Token amount (in token's decimals)
     * @param tokenDecimals Token decimals (e.g., 18 for ETH, 6 for USDC)
     * @return valueUSD USD value with 8 decimals
     */
    function getValueUSD(address token, uint256 amount, uint8 tokenDecimals)
        external
        view
        returns (uint256 valueUSD)
    {
        (int64 price, int32 expo, ) = this.getPrice(token);

        require(price > 0, "Invalid price");

        // Convert to USD value
        // Formula: (amount / 10^tokenDecimals) * (price / 10^|expo|)
        // Simplified: (amount * price) / (10^tokenDecimals * 10^|expo|)

        uint256 priceUint = uint256(uint64(price));
        uint256 expoAdjustment = uint256(10) ** uint256(int256(-expo)); // Pyth uses negative expos
        uint256 tokenAdjustment = uint256(10) ** uint256(tokenDecimals);

        // Result has 8 decimals (Pyth standard)
        valueUSD = (amount * priceUint * 1e8) / (tokenAdjustment * expoAdjustment);

        return valueUSD;
    }

    /**
     * @notice Get prices for multiple tokens
     * @param tokens Array of token addresses
     * @return prices Array of prices
     * @return expos Array of exponents
     * @return timestamps Array of timestamps
     */
    function getPrices(address[] calldata tokens)
        external
        view
        returns (
            int64[] memory prices,
            int32[] memory expos,
            uint256[] memory timestamps
        )
    {
        uint256 len = tokens.length;
        prices = new int64[](len);
        expos = new int32[](len);
        timestamps = new uint256[](len);

        for (uint256 i = 0; i < len; i++) {
            (prices[i], expos[i], timestamps[i]) = this.getPrice(tokens[i]);
        }

        return (prices, expos, timestamps);
    }

    /**
     * @notice Get all supported tokens
     * @return Array of supported token addresses
     */
    function getSupportedTokens() external view returns (address[] memory) {
        return supportedTokens;
    }

    /**
     * @notice Check if token is supported
     * @param token Token address
     * @return True if supported
     */
    function isSupported(address token) external view returns (bool) {
        return tokenToPriceId[token] != bytes32(0);
    }

    /**
     * @notice Validate price data
     * @param price Pyth price struct
     */
    function _validatePrice(PythStructs.Price memory price) internal view {
        // Check price is not negative
        if (price.price <= 0) revert PriceIsNegative();

        // Check staleness
        uint256 age = block.timestamp - price.publishTime;
        if (age > maxPriceAge) revert PriceTooOld(age, maxPriceAge);

        // Check confidence interval
        // Confidence should be small relative to price
        uint256 confidenceBps = (uint256(uint64(price.conf)) * 10000) / uint256(uint64(price.price));
        if (confidenceBps > minConfidenceBps) {
            revert PriceNotConfident(confidenceBps, minConfidenceBps);
        }
    }

    /**
     * @notice Update price feeds (call this before getting prices if needed)
     * @param updateData Array of price update data from Pyth API
     * @dev Caller must pay the update fee
     */
    function updatePriceFeeds(bytes[] calldata updateData) external payable nonReentrant {
        if (paused) revert OracleIsPaused();

        uint256 fee = pyth.getUpdateFee(updateData);
        require(msg.value >= fee, "Insufficient update fee");

        pyth.updatePriceFeeds{value: fee}(updateData);

        // Refund excess
        if (msg.value > fee) {
            (bool success, ) = msg.sender.call{value: msg.value - fee}("");
            require(success, "Refund failed");
        }
    }

    /**
     * @notice Get update fee for price feeds
     * @param updateData Price update data
     * @return fee Fee in native token (wei)
     */
    function getUpdateFee(bytes[] calldata updateData) external view returns (uint256 fee) {
        return pyth.getUpdateFee(updateData);
    }
}

================
File: contracts/vault/PQVault4626Demo.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {PQVault4626} from "./PQVault4626.sol";
import {IERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";

/// @title PQVault4626Demo
/// @notice Demo version of PQVault4626 with ACCELERATED vesting for testing/demonstrations
/// @dev WARNING: For demonstration ONLY. Uses 60x acceleration (1 month per minute).
///      DO NOT use for production. Inherits all security features from PQVault4626.
///
/// Time Acceleration:
/// - 1 minute real-time = 1 hour in demo
/// - 60 minutes (1 hour) = 60 hours (2.5 days) in demo
/// - 1 day (1440 min) = 1440 hours (60 days / 2 months) in demo
/// - Therefore: ~30 minutes real-time = 1 month vesting
///
/// Example Vesting Periods (real-time):
/// - 1 month vesting = ~30 minutes
/// - 3 month vesting = ~1.5 hours
/// - 6 month vesting = ~3 hours
/// - 1 year vesting = ~6 hours
///
/// Perfect for:
/// - Live demonstrations
/// - Quick testing
/// - User education
/// - Conference demos
contract PQVault4626Demo is PQVault4626 {
    /// @notice Acceleration factor: Each block represents 60x normal time
    /// @dev Block time is effectively 12 seconds * 60 = 720 seconds (12 minutes)
    ///      This means vesting that would take 30 days takes 30 minutes!
    uint256 public constant ACCELERATION_FACTOR = 60;

    /// @notice Accelerated block time (12 seconds * 60 = 720 seconds = 12 minutes)
    uint256 public constant DEMO_BLOCK_TIME = BLOCK_TIME * ACCELERATION_FACTOR;

    /// @notice Flag to indicate this is a demo contract
    bool public constant IS_DEMO = true;

    /// @notice Demo description
    string public constant DEMO_DESCRIPTION = "Fast-forward vesting: 1 month per 30 minutes";

    /// @notice Constructor
    /// @param asset_ The underlying ERC20 asset
    /// @param name_ The name of the vault token
    /// @param symbol_ The symbol of the vault token
    constructor(
        IERC20 asset_,
        string memory name_,
        string memory symbol_
    ) PQVault4626(asset_, name_, symbol_) {}

    /// @notice Deposit assets with ACCELERATED vesting schedule
    /// @dev Override to use accelerated block time calculations
    /// @param assets Amount of assets to deposit
    /// @param receiver Address receiving the shares
    /// @param vestingDuration Total vesting duration in seconds (will be accelerated)
    /// @param cliffDuration Cliff period in seconds (will be accelerated)
    /// @return shares Amount of shares minted
    function depositWithVesting(
        uint256 assets,
        address receiver,
        uint256 vestingDuration,
        uint256 cliffDuration
    ) external override returns (uint256 shares) {
        require(assets > 0, "Cannot deposit 0");
        require(receiver != address(0), "Invalid receiver");
        require(vestingDuration > 0, "Invalid vesting duration");
        require(vestingDuration <= 10 * 365 days, "Vesting too long"); // Max 10 years
        require(cliffDuration <= vestingDuration, "Cliff exceeds vesting");
        require(!vestingSchedules[receiver].active, "Vesting already active");

        // Convert time durations to ACCELERATED block counts
        // Each block represents DEMO_BLOCK_TIME instead of BLOCK_TIME
        uint256 vestingBlocks = vestingDuration / DEMO_BLOCK_TIME;
        uint256 cliffBlocks = cliffDuration / DEMO_BLOCK_TIME;

        // Prevent overflow in block number calculations
        require(block.number + vestingBlocks < type(uint64).max, "Block number overflow");

        // Calculate shares
        shares = previewDeposit(assets);
        require(shares > 0, "Zero shares");
        require(shares <= type(uint128).max, "Shares overflow");

        // Transfer assets from sender
        SafeERC20.safeTransferFrom(IERC20(asset()), msg.sender, address(this), assets);

        // Mint shares to this contract (held until vested)
        _mint(address(this), shares);

        // Create ACCELERATED vesting schedule using block numbers
        uint64 startBlock = uint64(block.number);
        vestingSchedules[receiver] = VestingSchedule({
            totalShares: uint128(shares),
            withdrawnShares: 0,
            cliffBlock: startBlock + uint64(cliffBlocks),
            vestingEndBlock: startBlock + uint64(vestingBlocks),
            startBlock: startBlock,
            active: true
        });

        emit DepositWithVesting(receiver, assets, shares, vestingDuration, cliffDuration);
        emit Deposit(msg.sender, receiver, assets, shares);

        return shares;
    }

    /// @notice Get demo vesting time estimates
    /// @param vestingDuration Desired vesting duration in normal time
    /// @return realTimeMinutes Approximate real-time duration in minutes
    /// @return demoBlocks Number of blocks required
    function getDemoTimeEstimate(uint256 vestingDuration)
        external
        pure
        returns (uint256 realTimeMinutes, uint256 demoBlocks)
    {
        demoBlocks = vestingDuration / DEMO_BLOCK_TIME;
        // Each block is 12 seconds, so total seconds = blocks * 12
        // Then convert to minutes
        realTimeMinutes = (demoBlocks * BLOCK_TIME) / 60;
        return (realTimeMinutes, demoBlocks);
    }

    /// @notice Get vesting information with demo context
    /// @param user The user address
    /// @return totalShares Total shares in vesting
    /// @return vestedShares Currently vested shares
    /// @return withdrawnShares Already withdrawn shares
    /// @return cliffBlock Cliff end block number
    /// @return vestingEndBlock Full vesting end block number
    /// @return isDemo Always true for this contract
    /// @return accelerationFactor The acceleration multiplier
    function getVestingInfoDemo(address user)
        external
        view
        returns (
            uint256 totalShares,
            uint256 vestedShares,
            uint256 withdrawnShares,
            uint256 cliffBlock,
            uint256 vestingEndBlock,
            bool isDemo,
            uint256 accelerationFactor
        )
    {
        VestingSchedule memory schedule = vestingSchedules[user];
        return (
            schedule.totalShares,
            _calculateVestedShares(user),
            schedule.withdrawnShares,
            schedule.cliffBlock,
            schedule.vestingEndBlock,
            IS_DEMO,
            ACCELERATION_FACTOR
        );
    }
}

================
File: contracts/vault/PQVault4626With83b.sol
================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "./PQVault4626WithPricing.sol";

/**
 * @title PQVault4626With83b
 * @notice Vesting vault with 83(b) election tracking and compliance features
 * @dev Handles native project token vesting with US tax compliance
 *
 * Prize Eligibility: PayPal USD Integration
 *
 * Tax Workflow:
 * 1. Employee receives vesting grant in native tokens
 * 2. Must file IRS 83(b) election within 30 days (critical!)
 * 3. Tokens vest over time (e.g., 4 years with 1-year cliff)
 * 4. When selling vested tokens → use PYUSD for tax withholding
 *
 * Features:
 * - 83(b) election deadline tracking
 * - Lockup period enforcement
 * - SEC compliance flags (Clarity Act / Torres ruling)
 * - PYUSD integration for tax withholding on sales
 */
contract PQVault4626With83b is PQVault4626WithPricing {

    /// @notice 83(b) election tracking
    struct Election83b {
        bool filed;                 // Whether 83(b) was filed
        uint64 grantDate;          // Date of grant (for 30-day deadline)
        uint64 filingDeadline;     // Grant date + 30 days
        uint64 filedDate;          // Actual filing date (0 if not filed)
        uint256 fairMarketValue;   // FMV at grant (for tax basis)
    }

    /// @notice Lockup and compliance tracking
    struct LockupInfo {
        uint64 lockupEndBlock;     // Company lockup period end
        bool companyLockup;        // Subject to company lockup?
        bool sec144Restriction;    // Subject to SEC Rule 144?
        uint256 maxSellPercent;    // Max % of holdings per sale (basis points)
    }

    /// @notice Mapping of user to 83(b) election info
    mapping(address => Election83b) public elections83b;

    /// @notice Mapping of user to lockup info
    mapping(address => LockupInfo) public lockupInfo;

    /// @notice PYUSD contract address for tax withholding
    address public constant PYUSD = 0x6c3ea9036406852006290770BEdFcAbA0e23A0e8;

    /// @notice Tax withholding percentage (basis points, 10000 = 100%)
    uint256 public defaultWithholdingBps = 2200; // 22% default federal

    /// @notice Treasury address for withheld taxes
    address public taxTreasury;

    // Events
    event Election83bFiled(address indexed user, uint256 fairMarketValue, uint64 filedDate);
    event Election83bDeadlineMissed(address indexed user, uint64 deadline);
    event LockupSet(address indexed user, uint64 lockupEndBlock, bool companyLockup);
    event TokensSoldWithTaxWithholding(
        address indexed user,
        uint256 tokenAmount,
        uint256 pyusdReceived,
        uint256 taxWithheld
    );
    event WithholdingRateUpdated(uint256 oldBps, uint256 newBps);

    // Errors
    error Election83bAlreadyFiled();
    error Election83bDeadlinePassed();
    error Election83bNotFiled();
    error StillInLockup(uint64 lockupEndBlock);
    error ExceedsMaxSellAmount(uint256 attempted, uint256 max);
    error InvalidWithholdingRate();

    /**
     * @notice Constructor
     * @param asset_ The underlying project token
     * @param name_ Vault name
     * @param symbol_ Vault symbol
     * @param decimals_ Token decimals
     * @param oracle_ Pyth price oracle
     * @param taxTreasury_ Address to receive withheld taxes
     */
    constructor(
        IERC20 asset_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        address oracle_,
        address taxTreasury_
    ) PQVault4626WithPricing(asset_, name_, symbol_, decimals_, oracle_) {
        require(taxTreasury_ != address(0), "Invalid tax treasury");
        taxTreasury = taxTreasury_;
    }

    /**
     * @notice Create vesting grant and initialize 83(b) deadline
     * @dev Called when granting equity to employee
     * @param assets Amount of tokens
     * @param receiver Employee address
     * @param vestingDuration Total vesting (e.g., 4 years)
     * @param cliffDuration Cliff period (e.g., 1 year)
     * @param fairMarketValue FMV per token at grant (for 83b)
     * @param hasCompanyLockup Subject to company lockup agreement?
     * @param lockupDuration Lockup period in seconds (if applicable)
     */
    function createGrantWith83b(
        uint256 assets,
        address receiver,
        uint256 vestingDuration,
        uint256 cliffDuration,
        uint256 fairMarketValue,
        bool hasCompanyLockup,
        uint256 lockupDuration
    ) external nonReentrant whenNotPaused returns (uint256 shares) {
        // Create normal vesting schedule
        shares = this.depositWithVestingAndPrice(assets, receiver, vestingDuration, cliffDuration);

        // Initialize 83(b) election tracking
        uint64 now64 = uint64(block.timestamp);
        elections83b[receiver] = Election83b({
            filed: false,
            grantDate: now64,
            filingDeadline: now64 + 30 days,
            filedDate: 0,
            fairMarketValue: fairMarketValue
        });

        // Set lockup info if applicable
        if (hasCompanyLockup) {
            uint64 lockupEndBlock = uint64(block.number + (lockupDuration / BLOCK_TIME));
            lockupInfo[receiver] = LockupInfo({
                lockupEndBlock: lockupEndBlock,
                companyLockup: true,
                sec144Restriction: true, // Assume SEC restrictions
                maxSellPercent: 1000     // 10% max per sale (Torres spirit)
            });

            emit LockupSet(receiver, lockupEndBlock, true);
        }

        return shares;
    }

    /**
     * @notice File 83(b) election (employee must do within 30 days)
     * @dev Records that employee filed with IRS
     * @param user Employee address (can be called by employee or admin)
     */
    function file83bElection(address user) external {
        Election83b storage election = elections83b[user];

        require(election.grantDate > 0, "No grant found");
        if (election.filed) revert Election83bAlreadyFiled();
        if (block.timestamp > election.filingDeadline) revert Election83bDeadlinePassed();

        election.filed = true;
        election.filedDate = uint64(block.timestamp);

        emit Election83bFiled(user, election.fairMarketValue, uint64(block.timestamp));
    }

    /**
     * @notice Check if 83(b) deadline was missed
     * @param user Employee address
     * @return missed True if deadline passed and not filed
     */
    function is83bDeadlineMissed(address user) public view returns (bool missed) {
        Election83b memory election = elections83b[user];
        return election.grantDate > 0
            && !election.filed
            && block.timestamp > election.filingDeadline;
    }

    /**
     * @notice Sell vested tokens with automatic PYUSD tax withholding
     * @dev Employee sells tokens, receives PYUSD minus withholding
     * @param tokenAmount Amount of vested tokens to sell
     * @param minPyusdOut Minimum PYUSD to receive (slippage protection)
     * @param swapData DEX swap data (e.g., Uniswap path)
     * @return pyusdReceived Amount of PYUSD sent to user (after tax)
     * @return taxWithheld Amount of PYUSD withheld for taxes
     */
    function sellVestedWithTaxWithholding(
        uint256 tokenAmount,
        uint256 minPyusdOut,
        bytes calldata swapData
    ) external nonReentrant returns (uint256 pyusdReceived, uint256 taxWithheld) {
        // Check 83(b) election status
        Election83b memory election = elections83b[msg.sender];
        if (election.grantDate > 0 && !election.filed) {
            // Warning: not filed = tax on vesting + tax on gains
            emit Election83bDeadlineMissed(msg.sender, election.filingDeadline);
        }

        // Check lockup restrictions
        LockupInfo memory lockup = lockupInfo[msg.sender];
        if (lockup.companyLockup && block.number < lockup.lockupEndBlock) {
            revert StillInLockup(lockup.lockupEndBlock);
        }

        // Check max sell amount (Torres ruling compliance)
        if (lockup.maxSellPercent > 0) {
            uint256 totalVested = _calculateVestedShares(msg.sender);
            uint256 maxSell = (totalVested * lockup.maxSellPercent) / 10000;
            if (tokenAmount > maxSell) {
                revert ExceedsMaxSellAmount(tokenAmount, maxSell);
            }
        }

        // Withdraw vested tokens to this contract
        uint256 shares = previewWithdraw(tokenAmount);
        _withdrawVested(msg.sender, shares);

        // Swap tokens → PYUSD (via DEX integration)
        uint256 totalPyusd = _swapToPYUSD(tokenAmount, minPyusdOut, swapData);

        // Calculate tax withholding
        taxWithheld = (totalPyusd * defaultWithholdingBps) / 10000;
        pyusdReceived = totalPyusd - taxWithheld;

        // Transfer PYUSD to user
        IERC20(PYUSD).transfer(msg.sender, pyusdReceived);

        // Transfer withheld taxes to treasury
        IERC20(PYUSD).transfer(taxTreasury, taxWithheld);

        emit TokensSoldWithTaxWithholding(msg.sender, tokenAmount, pyusdReceived, taxWithheld);

        return (pyusdReceived, taxWithheld);
    }

    /**
     * @notice Update withholding rate (for different states/countries)
     * @param newBps New withholding rate in basis points
     */
    function setWithholdingRate(uint256 newBps) external onlyOwner {
        require(newBps <= 5000, "Max 50% withholding"); // Sanity check
        uint256 oldBps = defaultWithholdingBps;
        defaultWithholdingBps = newBps;
        emit WithholdingRateUpdated(oldBps, newBps);
    }

    /**
     * @notice Get 83(b) election info
     * @param user Employee address
     * @return Election info struct
     */
    function get83bInfo(address user) external view returns (Election83b memory) {
        return elections83b[user];
    }

    /**
     * @notice Get lockup and compliance info
     * @param user Employee address
     * @return Lockup info struct
     */
    function getLockupInfo(address user) external view returns (LockupInfo memory) {
        return lockupInfo[user];
    }

    /**
     * @notice Internal: Swap project tokens to PYUSD via DEX
     * @dev Override this with actual DEX integration (Uniswap, etc.)
     */
    function _swapToPYUSD(
        uint256 tokenAmount,
        uint256 minPyusdOut,
        bytes calldata swapData
    ) internal virtual returns (uint256 pyusdAmount) {
        // TODO: Implement actual DEX swap
        // For now, this is a placeholder that would integrate with:
        // - Uniswap V3
        // - 1inch aggregator
        // - Cowswap (MEV protection)

        // Example: Approve token to DEX router
        // IERC20(asset()).approve(DEX_ROUTER, tokenAmount);
        // pyusdAmount = IRouter(DEX_ROUTER).swap(token, PYUSD, tokenAmount, minPyusdOut, swapData);

        revert("DEX integration required");
    }

    /**
     * @notice Internal: Withdraw vested shares
     */
    function _withdrawVested(address user, uint256 shares) internal {
        VestingSchedule storage schedule = vestingSchedules[user];
        require(schedule.active, "No active vesting");

        uint256 vestedShares = _calculateVestedShares(user);
        uint256 availableShares = vestedShares - schedule.withdrawnShares;
        require(shares <= availableShares, "Insufficient vested shares");

        schedule.withdrawnShares += uint128(shares);
    }
}

================
File: contracts/vault/PQVault4626WithPricing.sol
================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "./PQVault4626.sol";
import "../oracles/PythPriceOracle.sol";

/**
 * @title PQVault4626WithPricing
 * @notice Enhanced PQVault4626 with Pyth Network price oracle integration
 * @dev Adds USD valuation and multi-currency pricing to vesting schedules
 *
 * Prize Eligibility: Pyth Network Integration
 *
 * Features:
 * - Real-time USD valuation of vested tokens
 * - Multi-currency price queries (USD, ETH, BTC)
 * - Historical value tracking
 * - Price-based vesting milestones
 */
contract PQVault4626WithPricing is PQVault4626 {
    /// @notice Pyth price oracle contract
    PythPriceOracle public priceOracle;

    /// @notice Token decimals (for price calculations)
    uint8 public immutable assetDecimals;

    /// @notice Price history tracking
    struct PriceSnapshot {
        uint64 timestamp;
        int64 price;       // USD price with 8 decimals
        uint64 blockNumber;
    }

    /// @notice Price snapshots at vesting milestones
    mapping(address => PriceSnapshot[]) public priceHistory;

    // Events
    event PriceOracleUpdated(address indexed oldOracle, address indexed newOracle);
    event PriceSnapshotRecorded(address indexed user, int64 price, uint64 timestamp);
    event VestingValueQueried(address indexed user, uint256 valueUSD, uint256 shares);

    // Errors
    error PriceOracleNotSet();
    error InvalidPriceOracle();

    /**
     * @notice Constructor
     * @param asset_ The underlying ERC20 asset
     * @param name_ The name of the vault token
     * @param symbol_ The symbol of the vault token
     * @param decimals_ Token decimals
     * @param oracle_ Pyth price oracle address
     */
    constructor(
        IERC20 asset_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        address oracle_
    ) PQVault4626(asset_, name_, symbol_) {
        assetDecimals = decimals_;
        if (oracle_ != address(0)) {
            priceOracle = PythPriceOracle(oracle_);
        }
    }

    /**
     * @notice Set or update price oracle
     * @param oracle_ New oracle address
     */
    function setPriceOracle(address oracle_) external onlyOwner {
        require(oracle_ != address(0), "Invalid oracle");
        address oldOracle = address(priceOracle);
        priceOracle = PythPriceOracle(oracle_);
        emit PriceOracleUpdated(oldOracle, oracle_);
    }

    /**
     * @notice Deposit with vesting and record initial price
     * @dev Extends parent to add price snapshot
     */
    function depositWithVestingAndPrice(
        uint256 assets,
        address receiver,
        uint256 vestingDuration,
        uint256 cliffDuration
    ) external nonReentrant whenNotPaused returns (uint256 shares) {
        require(assets > 0, "Cannot deposit 0");
        require(receiver != address(0), "Invalid receiver");
        require(vestingDuration > 0, "Invalid vesting duration");
        require(vestingDuration <= 10 * 365 days, "Vesting too long");
        require(cliffDuration <= vestingDuration, "Cliff exceeds vesting");
        require(!vestingSchedules[receiver].active, "Vesting already active");

        // Convert time durations to block counts
        uint256 vestingBlocks = vestingDuration / BLOCK_TIME;
        uint256 cliffBlocks = cliffDuration / BLOCK_TIME;

        require(block.number + vestingBlocks < type(uint64).max, "Block number overflow");

        // Calculate shares
        shares = previewDeposit(assets);
        require(shares > 0, "Zero shares");
        require(shares <= type(uint128).max, "Shares overflow");

        // Transfer assets from sender
        SafeERC20.safeTransferFrom(IERC20(asset()), msg.sender, address(this), assets);

        // Mint shares to this contract
        _mint(address(this), shares);

        // Create vesting schedule
        uint64 startBlock = uint64(block.number);
        vestingSchedules[receiver] = VestingSchedule({
            totalShares: uint128(shares),
            withdrawnShares: 0,
            cliffBlock: startBlock + uint64(cliffBlocks),
            vestingEndBlock: startBlock + uint64(vestingBlocks),
            startBlock: startBlock,
            active: true
        });

        emit DepositWithVesting(receiver, assets, shares, vestingDuration, cliffDuration);
        emit Deposit(msg.sender, receiver, assets, shares);

        // Record price snapshot if oracle is set
        if (address(priceOracle) != address(0)) {
            _recordPriceSnapshot(receiver);
        }

        return shares;
    }

    /**
     * @notice Get current USD value of user's vested shares
     * @param user User address
     * @return valueUSD USD value with 8 decimals
     * @return vestedShares Number of vested shares
     */
    function getVestedValueUSD(address user)
        external
        view
        returns (uint256 valueUSD, uint256 vestedShares)
    {
        if (address(priceOracle) == address(0)) revert PriceOracleNotSet();

        vestedShares = _calculateVestedShares(user);
        if (vestedShares == 0) return (0, 0);

        // Convert shares to assets
        uint256 vestedAssets = convertToAssets(vestedShares);

        // Get USD value from oracle
        valueUSD = priceOracle.getValueUSD(asset(), vestedAssets, assetDecimals);

        return (valueUSD, vestedShares);
    }

    /**
     * @notice Get current USD value of user's total vesting
     * @param user User address
     * @return totalValueUSD Total USD value with 8 decimals
     * @return vestedValueUSD Currently vested USD value
     * @return unvestedValueUSD Not yet vested USD value
     */
    function getVestingValueBreakdown(address user)
        external
        view
        returns (
            uint256 totalValueUSD,
            uint256 vestedValueUSD,
            uint256 unvestedValueUSD
        )
    {
        if (address(priceOracle) == address(0)) revert PriceOracleNotSet();

        VestingSchedule memory schedule = vestingSchedules[user];
        if (!schedule.active) return (0, 0, 0);

        // Total vesting value
        uint256 totalAssets = convertToAssets(schedule.totalShares);
        totalValueUSD = priceOracle.getValueUSD(asset(), totalAssets, assetDecimals);

        // Vested value
        uint256 vestedShares = _calculateVestedShares(user);
        uint256 vestedAssets = convertToAssets(vestedShares);
        vestedValueUSD = priceOracle.getValueUSD(asset(), vestedAssets, assetDecimals);

        // Unvested value
        unvestedValueUSD = totalValueUSD - vestedValueUSD;

        return (totalValueUSD, vestedValueUSD, unvestedValueUSD);
    }

    /**
     * @notice Get current token price from oracle
     * @return price USD price with 8 decimals
     * @return timestamp Price timestamp
     */
    function getCurrentPrice()
        external
        view
        returns (int64 price, uint256 timestamp)
    {
        if (address(priceOracle) == address(0)) revert PriceOracleNotSet();
        (price, , timestamp) = priceOracle.getPrice(asset());
        return (price, timestamp);
    }

    /**
     * @notice Get price history for a user's vesting
     * @param user User address
     * @return Array of price snapshots
     */
    function getPriceHistory(address user)
        external
        view
        returns (PriceSnapshot[] memory)
    {
        return priceHistory[user];
    }

    /**
     * @notice Get vesting progress with price data
     * @param user User address
     * @return percentVested Percentage vested (basis points, 10000 = 100%)
     * @return vestedShares Number of vested shares
     * @return totalShares Total shares in vesting
     * @return currentValueUSD Current USD value of vested shares
     * @return initialPrice Initial price when vesting started
     * @return currentPrice Current price
     */
    function getVestingProgress(address user)
        external
        view
        returns (
            uint256 percentVested,
            uint256 vestedShares,
            uint256 totalShares,
            uint256 currentValueUSD,
            int64 initialPrice,
            int64 currentPrice
        )
    {
        VestingSchedule memory schedule = vestingSchedules[user];
        if (!schedule.active) return (0, 0, 0, 0, 0, 0);

        vestedShares = _calculateVestedShares(user);
        totalShares = schedule.totalShares;
        percentVested = (vestedShares * 10000) / totalShares;

        if (address(priceOracle) != address(0)) {
            // Current value
            uint256 vestedAssets = convertToAssets(vestedShares);
            currentValueUSD = priceOracle.getValueUSD(asset(), vestedAssets, assetDecimals);

            // Initial and current prices
            PriceSnapshot[] memory history = priceHistory[user];
            if (history.length > 0) {
                initialPrice = history[0].price;
            }

            (currentPrice, , ) = priceOracle.getPrice(asset());
        }

        return (percentVested, vestedShares, totalShares, currentValueUSD, initialPrice, currentPrice);
    }

    /**
     * @notice Record a price snapshot for a user
     * @param user User address
     */
    function _recordPriceSnapshot(address user) internal {
        try priceOracle.getPrice(asset()) returns (int64 price, int32, uint256 timestamp) {
            priceHistory[user].push(
                PriceSnapshot({
                    timestamp: uint64(timestamp),
                    price: price,
                    blockNumber: uint64(block.number)
                })
            );

            emit PriceSnapshotRecorded(user, price, uint64(timestamp));
        } catch {
            // Silently fail if price not available
            // This prevents deposit from reverting due to oracle issues
        }
    }

    /**
     * @notice Manually record price snapshot (for milestone tracking)
     * @dev Can be called by anyone to update price history
     */
    function recordPriceSnapshot() external {
        if (address(priceOracle) == address(0)) revert PriceOracleNotSet();
        if (!vestingSchedules[msg.sender].active) revert("No active vesting");

        _recordPriceSnapshot(msg.sender);
    }

    /**
     * @notice Estimate future vesting value at a given block
     * @param user User address
     * @param futureBlock Future block number
     * @return estimatedShares Estimated vested shares at that block
     * @return estimatedValueUSD Estimated USD value (using current price)
     */
    function estimateFutureValue(address user, uint256 futureBlock)
        external
        view
        returns (uint256 estimatedShares, uint256 estimatedValueUSD)
    {
        if (address(priceOracle) == address(0)) revert PriceOracleNotSet();

        VestingSchedule memory schedule = vestingSchedules[user];
        if (!schedule.active) return (0, 0);

        // Calculate shares that will be vested at future block
        if (futureBlock < schedule.cliffBlock) {
            estimatedShares = 0;
        } else if (futureBlock >= schedule.vestingEndBlock) {
            estimatedShares = schedule.totalShares;
        } else {
            uint256 vestingBlocks = schedule.vestingEndBlock - schedule.cliffBlock;
            uint256 blocksVested = futureBlock - schedule.cliffBlock;
            estimatedShares = (uint256(schedule.totalShares) * blocksVested) / vestingBlocks;
        }

        // Estimate value using current price
        if (estimatedShares > 0) {
            uint256 estimatedAssets = convertToAssets(estimatedShares);
            estimatedValueUSD = priceOracle.getValueUSD(asset(), estimatedAssets, assetDecimals);
        }

        return (estimatedShares, estimatedValueUSD);
    }
}

================
File: contracts/vault/VestingManager.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {IERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
import {ReentrancyGuard} from "lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol";
import {Ownable} from "lib/openzeppelin-contracts/contracts/access/Ownable.sol";

/// @title VestingManager
/// @notice Manages time-locked vesting schedules for multiple beneficiaries
/// @dev Supports linear and cliff-based vesting
contract VestingManager is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    /// @notice Vesting schedule structure
    struct VestingSchedule {
        address beneficiary;        // Who receives the tokens
        uint256 totalAmount;        // Total tokens to be vested
        uint256 releasedAmount;     // Tokens already released
        uint64 startTimestamp;      // Vesting start time
        uint64 cliffDuration;       // Cliff period in seconds
        uint64 vestingDuration;     // Total vesting duration
        bool revocable;             // Can the schedule be revoked
        bool revoked;               // Has it been revoked
    }

    /// @notice The token being vested
    IERC20 public immutable token;

    /// @notice Counter for vesting schedule IDs
    uint256 public nextScheduleId;

    /// @notice Mapping of schedule ID to vesting schedule
    mapping(uint256 => VestingSchedule) public vestingSchedules;

    /// @notice Mapping of beneficiary to their schedule IDs
    mapping(address => uint256[]) public beneficiarySchedules;

    /// @notice Emitted when a vesting schedule is created
    event VestingScheduleCreated(
        uint256 indexed scheduleId,
        address indexed beneficiary,
        uint256 amount,
        uint64 startTimestamp,
        uint64 cliffDuration,
        uint64 vestingDuration,
        bool revocable
    );

    /// @notice Emitted when tokens are released
    event TokensReleased(
        uint256 indexed scheduleId,
        address indexed beneficiary,
        uint256 amount
    );

    /// @notice Emitted when a schedule is revoked
    event VestingScheduleRevoked(
        uint256 indexed scheduleId,
        address indexed beneficiary,
        uint256 unvestedAmount
    );

    /// @notice Constructor
    /// @param _token The token to be vested
    constructor(IERC20 _token) Ownable(msg.sender) {
        require(address(_token) != address(0), "Invalid token");
        token = _token;
    }

    /// @notice Create a new vesting schedule
    /// @param beneficiary Who will receive the vested tokens
    /// @param amount Total amount to vest
    /// @param cliffDuration Cliff period in seconds
    /// @param vestingDuration Total vesting duration in seconds
    /// @param revocable Can this schedule be revoked
    /// @return scheduleId The ID of the created schedule
    function createVestingSchedule(
        address beneficiary,
        uint256 amount,
        uint64 cliffDuration,
        uint64 vestingDuration,
        bool revocable
    ) external onlyOwner returns (uint256 scheduleId) {
        require(beneficiary != address(0), "Invalid beneficiary");
        require(amount > 0, "Amount must be > 0");
        require(vestingDuration > 0, "Duration must be > 0");
        require(cliffDuration <= vestingDuration, "Cliff exceeds duration");

        // Transfer tokens to this contract
        token.safeTransferFrom(msg.sender, address(this), amount);

        // Create schedule
        scheduleId = nextScheduleId++;
        vestingSchedules[scheduleId] = VestingSchedule({
            beneficiary: beneficiary,
            totalAmount: amount,
            releasedAmount: 0,
            startTimestamp: uint64(block.timestamp),
            cliffDuration: cliffDuration,
            vestingDuration: vestingDuration,
            revocable: revocable,
            revoked: false
        });

        beneficiarySchedules[beneficiary].push(scheduleId);

        emit VestingScheduleCreated(
            scheduleId,
            beneficiary,
            amount,
            uint64(block.timestamp),
            cliffDuration,
            vestingDuration,
            revocable
        );

        return scheduleId;
    }

    /// @notice Release vested tokens for a schedule
    /// @param scheduleId The vesting schedule ID
    function release(uint256 scheduleId) external nonReentrant {
        VestingSchedule storage schedule = vestingSchedules[scheduleId];
        require(schedule.beneficiary != address(0), "Schedule does not exist");
        require(msg.sender == schedule.beneficiary, "Not beneficiary");
        require(!schedule.revoked, "Schedule revoked");

        uint256 releasable = _releasableAmount(scheduleId);
        require(releasable > 0, "No tokens to release");

        schedule.releasedAmount += releasable;
        token.safeTransfer(schedule.beneficiary, releasable);

        emit TokensReleased(scheduleId, schedule.beneficiary, releasable);
    }

    /// @notice Revoke a vesting schedule
    /// @param scheduleId The schedule to revoke
    function revoke(uint256 scheduleId) external onlyOwner {
        VestingSchedule storage schedule = vestingSchedules[scheduleId];
        require(schedule.beneficiary != address(0), "Schedule does not exist");
        require(schedule.revocable, "Schedule not revocable");
        require(!schedule.revoked, "Already revoked");

        uint256 releasable = _releasableAmount(scheduleId);
        uint256 unvested = schedule.totalAmount - schedule.releasedAmount - releasable;

        schedule.revoked = true;

        // Transfer unvested tokens back to owner
        if (unvested > 0) {
            token.safeTransfer(owner(), unvested);
        }

        // Release any vested tokens to beneficiary
        if (releasable > 0) {
            schedule.releasedAmount += releasable;
            token.safeTransfer(schedule.beneficiary, releasable);
        }

        emit VestingScheduleRevoked(scheduleId, schedule.beneficiary, unvested);
    }

    /// @notice Calculate releasable amount for a schedule
    /// @param scheduleId The schedule ID
    /// @return Amount of tokens that can be released
    function _releasableAmount(uint256 scheduleId) internal view returns (uint256) {
        VestingSchedule memory schedule = vestingSchedules[scheduleId];

        if (schedule.revoked) {
            return 0;
        }

        uint256 vestedAmount = _vestedAmount(scheduleId);
        return vestedAmount - schedule.releasedAmount;
    }

    /// @notice Calculate vested amount for a schedule
    /// @param scheduleId The schedule ID
    /// @return Amount of tokens vested
    function _vestedAmount(uint256 scheduleId) internal view returns (uint256) {
        VestingSchedule memory schedule = vestingSchedules[scheduleId];

        uint64 cliffEnd = schedule.startTimestamp + schedule.cliffDuration;
        uint64 vestingEnd = schedule.startTimestamp + schedule.vestingDuration;

        // Before cliff
        if (block.timestamp < cliffEnd) {
            return 0;
        }

        // After full vesting
        if (block.timestamp >= vestingEnd) {
            return schedule.totalAmount;
        }

        // Linear vesting between cliff and end
        uint256 vestingPeriod = vestingEnd - cliffEnd;
        uint256 timeVested = block.timestamp - cliffEnd;

        return (schedule.totalAmount * timeVested) / vestingPeriod;
    }

    /// @notice Get vested amount for a schedule (external)
    /// @param scheduleId The schedule ID
    /// @return Amount vested
    function getVestedAmount(uint256 scheduleId) external view returns (uint256) {
        return _vestedAmount(scheduleId);
    }

    /// @notice Get releasable amount for a schedule (external)
    /// @param scheduleId The schedule ID
    /// @return Amount releasable
    function getReleasableAmount(uint256 scheduleId) external view returns (uint256) {
        return _releasableAmount(scheduleId);
    }

    /// @notice Get all schedule IDs for a beneficiary
    /// @param beneficiary The beneficiary address
    /// @return Array of schedule IDs
    function getBeneficiarySchedules(address beneficiary) external view returns (uint256[] memory) {
        return beneficiarySchedules[beneficiary];
    }
}

================
File: contracts/verifiers/Groth16VerifierReal.sol
================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 5545267496508946799221565806977726573654132117655929581462170913718803536656;
    uint256 constant deltax2 = 12686179474803065396430560701304284205562723911493047724586030562835261798978;
    uint256 constant deltay1 = 18111317904928840914695333552344038626104980797661582974899355583455192249942;
    uint256 constant deltay2 = 2356986648357960532981017539074137046361824411008426893435898650222235749926;


    uint256 constant IC0x = 13408175294979748847420542970500247690448619877624937076964670201361603780817;
    uint256 constant IC0y = 16132362823058559644485353518489533107371901955584854686400331093168295742272;

    uint256 constant IC1x = 21464698893065581194753115776432885962985534553173833066143560649167939811998;
    uint256 constant IC1y = 2919993756229327258553882848463384848453849541594614183751735447995816704848;

    uint256 constant IC2x = 20119487466768500791549091710877118025038754241446499365713652073054866334965;
    uint256 constant IC2y = 12258222361276494126586738840298456688492306128078998404074253541664936042414;


    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[2] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x

                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))

                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))


                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F

            checkField(calldataload(add(_pubSignals, 0)))

            checkField(calldataload(add(_pubSignals, 32)))


            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }

================
File: contracts/DilithiumVerifier.sol
================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant deltax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant deltay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant deltay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;

    
    uint256 constant IC0x = 5643694953456527190232183016330895932015994476149011498556800185083345312697;
    uint256 constant IC0y = 14560851058832434257210256937428388146337344360629794954001695858497581072562;
    
    uint256 constant IC1x = 13285652348921903445475087124685655409213895880845488657281068703545127340309;
    uint256 constant IC1y = 4314106359500424705861081728305630570644102054037384514054017819403226162454;
    
    uint256 constant IC2x = 5896385880282525758370130374957945975471764595182492413510131817201168180312;
    uint256 constant IC2y = 14621918091839317125943319587271186130026811847622628311415818659015264401324;
    
    uint256 constant IC3x = 1102224904658985556606863711645681684259447603664867395475350118623317287277;
    uint256 constant IC3y = 10809203031627525590333031732612924985546214872224408428897413372392558765915;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[3] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }

================
File: contracts/interfaces/IPQValidator.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/// @title IPQValidator
/// @notice Interface for Post-Quantum signature validation
interface IPQValidator {
    /// @notice Verify a post-quantum signature
    /// @param message The message that was signed
    /// @param signature The post-quantum signature
    /// @param publicKey The post-quantum public key
    /// @return True if signature is valid
    function verifySignature(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) external view returns (bool);

    /// @notice Verify a SPHINCS+ signature
    /// @param message The message that was signed
    /// @param signature The SPHINCS+ signature
    /// @param publicKey The SPHINCS+ public key
    /// @return True if signature is valid
    function verifySPHINCSPlus(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) external pure returns (bool);

    /// @notice Verify a Dilithium signature
    /// @param message The message that was signed
    /// @param signature The Dilithium signature
    /// @param publicKey The Dilithium public key
    /// @return True if signature is valid
    function verifyDilithium(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) external view returns (bool);
}

================
File: contracts/libraries/DilithiumVerifier.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/// @title DilithiumVerifier
/// @notice Implementation of Dilithium3 signature verification (NIST PQC standard)
/// @dev Based on CRYSTALS-Dilithium specification: https://pq-crystals.org/dilithium/
/// @author EthVaultPQ Team
library DilithiumVerifier {
    // Dilithium3 parameters (NIST security level 3, ~128-bit quantum security)
    uint256 constant Q = 8380417; // Prime modulus
    uint256 constant D = 13; // Dropped bits from t
    uint256 constant TAU = 49; // Number of ±1's in c
    uint256 constant GAMMA1 = 1 << 19; // (Q-1)/32
    uint256 constant GAMMA2 = (Q - 1) / 32; // 261888
    uint256 constant K = 6; // Dimensions of matrix A (rows)
    uint256 constant L = 5; // Dimensions of matrix A (cols)
    uint256 constant ETA = 4; // Secret key range
    uint256 constant BETA = 196; // τ * η
    uint256 constant OMEGA = 55; // Maximum number of 1's in hint h

    // Size constants
    uint256 constant SEEDBYTES = 32;
    uint256 constant CRHBYTES = 64;
    uint256 constant N = 256; // Polynomial degree
    uint256 constant POLYT1_PACKEDBYTES = 320;
    uint256 constant POLYT0_PACKEDBYTES = 416;
    uint256 constant POLYZ_PACKEDBYTES = 640;
    uint256 constant POLYW1_PACKEDBYTES = 192;
    uint256 constant POLYETA_PACKEDBYTES = 128;

    uint256 constant CRYPTO_PUBLICKEYBYTES = SEEDBYTES + K * POLYT1_PACKEDBYTES; // 1952 bytes
    uint256 constant CRYPTO_SECRETKEYBYTES = 2 * SEEDBYTES + CRHBYTES + L * POLYETA_PACKEDBYTES + K * POLYETA_PACKEDBYTES + K * POLYT0_PACKEDBYTES; // 4000 bytes
    uint256 constant CRYPTO_BYTES = SEEDBYTES + L * POLYZ_PACKEDBYTES + OMEGA + K; // 3293 bytes

    /// @notice Error codes for verification failures
    error InvalidSignatureLength();
    error InvalidPublicKeyLength();
    error InvalidMessageLength();
    error SignatureVerificationFailed();
    error NormCheckFailed();
    error HintCheckFailed();

    /// @notice Verify a Dilithium3 signature
    /// @param message The message that was signed
    /// @param signature The Dilithium signature (3293 bytes)
    /// @param publicKey The Dilithium public key (1952 bytes)
    /// @return True if signature is valid
    function verify(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) internal pure returns (bool) {
        // Validate input lengths
        if (signature.length != CRYPTO_BYTES) revert InvalidSignatureLength();
        if (publicKey.length != CRYPTO_PUBLICKEYBYTES) revert InvalidPublicKeyLength();
        if (message.length == 0) revert InvalidMessageLength();

        // Parse public key: pk = (ρ, t1)
        bytes32 rho = _extractBytes32(publicKey, 0);

        // Parse signature: sig = (c̃, z, h)
        bytes32 c_tilde = _extractBytes32(signature, 0);

        // Expand matrix A from ρ (seed)
        // In a full implementation, this would use SHAKE-128 to expand A
        // For now, we'll implement a simplified version

        // Hash the message with public key to get μ
        bytes32 mu = keccak256(abi.encodePacked(publicKey, message));

        // Verify signature components
        // 1. Reconstruct c from c̃
        // 2. Compute w1' = Az - ct1·2^d (mod q)
        // 3. Compute c' = H(μ, w1')
        // 4. Check c' == c
        // 5. Check ||z|| < γ₁ - β
        // 6. Check hint h is valid

        // For a production implementation, we need:
        bool normCheck = _verifyNorms(signature);
        bool hintCheck = _verifyHint(signature);
        bool hashCheck = _verifyHash(mu, c_tilde, signature, publicKey);

        return normCheck && hintCheck && hashCheck;
    }

    /// @notice Verify that z polynomial has acceptable norm
    /// @param signature The signature containing z
    /// @return True if norm is valid
    function _verifyNorms(bytes memory signature) private pure returns (bool) {
        // Extract z polynomials (L polynomials of 640 bytes each)
        uint256 offset = SEEDBYTES; // Skip c̃

        for (uint256 i = 0; i < L; i++) {
            // Each z polynomial should have coefficients in range [-(γ₁ - β), γ₁ - β]
            // In a full implementation, we'd unpack and check each coefficient

            // Simplified check: verify the packed bytes exist
            if (offset + POLYZ_PACKEDBYTES > signature.length) {
                revert NormCheckFailed();
            }

            offset += POLYZ_PACKEDBYTES;
        }

        return true;
    }

    /// @notice Verify hint polynomial h
    /// @param signature The signature containing h
    /// @return True if hint is valid
    function _verifyHint(bytes memory signature) private pure returns (bool) {
        // Hint h should have at most OMEGA non-zero coefficients
        uint256 hintOffset = SEEDBYTES + L * POLYZ_PACKEDBYTES;

        if (hintOffset + OMEGA + K > signature.length) {
            revert HintCheckFailed();
        }

        // Count non-zero hint coefficients
        uint256 nonZeroCount = 0;
        for (uint256 i = 0; i < OMEGA + K; i++) {
            if (uint8(signature[hintOffset + i]) != 0) {
                nonZeroCount++;
            }
        }

        // Must have at most OMEGA non-zero coefficients
        return nonZeroCount <= OMEGA;
    }

    /// @notice Verify the hash check: H(μ, w1') == c
    /// @param mu The message hash
    /// @param c_tilde The challenge from signature
    /// @param signature The full signature
    /// @param publicKey The public key
    /// @return True if hash matches
    function _verifyHash(
        bytes32 mu,
        bytes32 c_tilde,
        bytes memory signature,
        bytes memory publicKey
    ) private pure returns (bool) {
        // In a full implementation:
        // 1. Expand A from seed in publicKey
        // 2. Unpack t1 from publicKey
        // 3. Unpack z from signature
        // 4. Compute w1' = Az - ct1·2^d (mod q)
        // 5. Hash: c' = H(μ, w1')
        // 6. Compare c' with c_tilde

        // For now, use a simplified hash check
        bytes32 computed = keccak256(abi.encodePacked(mu, publicKey, signature));

        // In production, this should expand c from c_tilde and compare properly
        // The challenge c has exactly TAU (49) non-zero coefficients in {-1, 0, 1}

        return computed != bytes32(0); // Simplified: just check non-zero
    }

    /// @notice Extract 32 bytes from a bytes array at given offset
    /// @param data The bytes array
    /// @param offset The starting offset
    /// @return result The extracted bytes32
    function _extractBytes32(bytes memory data, uint256 offset) private pure returns (bytes32 result) {
        require(offset + 32 <= data.length, "Offset out of bounds");
        assembly {
            result := mload(add(add(data, 32), offset))
        }
    }

    /// @notice Polynomial coefficient reduction modulo Q
    /// @param a The value to reduce
    /// @return The reduced value in [0, Q)
    function _modQ(uint256 a) private pure returns (uint256) {
        return a % Q;
    }

    /// @notice NTT (Number Theoretic Transform) for polynomial multiplication
    /// @dev This is a placeholder - full implementation needed for production
    /// @param poly The polynomial coefficients
    /// @return The NTT of the polynomial
    function _ntt(uint256[N] memory poly) private pure returns (uint256[N] memory) {
        // Number Theoretic Transform for fast polynomial multiplication in Zq[x]/(x^256 + 1)
        // This requires implementing the full NTT butterfly operations
        // Root of unity: ω = 1753

        // For production: implement Cooley-Tukey NTT algorithm
        return poly; // Placeholder
    }

    /// @notice Inverse NTT
    /// @param poly The NTT-transformed polynomial
    /// @return The polynomial in normal form
    function _invNtt(uint256[N] memory poly) private pure returns (uint256[N] memory) {
        // Inverse NTT with scaling by n^(-1) mod q
        return poly; // Placeholder
    }

    /// @notice Multiply two polynomials in NTT domain
    /// @param a First polynomial (in NTT form)
    /// @param b Second polynomial (in NTT form)
    /// @return Result of multiplication (in NTT form)
    function _polyMultNTT(
        uint256[N] memory a,
        uint256[N] memory b
    ) private pure returns (uint256[N] memory) {
        uint256[N] memory result;
        for (uint256 i = 0; i < N; i++) {
            result[i] = _modQ(a[i] * b[i]);
        }
        return result;
    }

    /// @notice Pack polynomial with coefficients in [0, 2*GAMMA2)
    /// @param poly The polynomial to pack
    /// @return The packed bytes
    function _packW1(uint256[N] memory poly) private pure returns (bytes memory) {
        bytes memory packed = new bytes(POLYW1_PACKEDBYTES);
        // Packing logic: each coefficient uses log2(Q/GAMMA2) bits
        // Implementation details omitted for brevity
        return packed;
    }

    /// @notice Unpack z polynomial
    /// @param packed The packed polynomial bytes
    /// @return The unpacked polynomial coefficients
    function _unpackZ(bytes memory packed) private pure returns (uint256[N] memory) {
        uint256[N] memory poly;
        // Unpacking logic: coefficients are in [-(GAMMA1-1), GAMMA1]
        // Implementation details omitted for brevity
        return poly;
    }

    /// @notice Check if polynomial infinity norm is less than bound
    /// @param poly The polynomial to check
    /// @param bound The bound to check against
    /// @return True if ||poly||∞ < bound
    function _checkNormInf(uint256[N] memory poly, uint256 bound) private pure returns (bool) {
        for (uint256 i = 0; i < N; i++) {
            uint256 coeff = poly[i];
            // Convert to signed representation
            if (coeff > Q / 2) {
                coeff = Q - coeff;
            }
            if (coeff >= bound) {
                return false;
            }
        }
        return true;
    }

    /// @notice Expand challenge polynomial from seed
    /// @param seed The challenge seed
    /// @return The challenge polynomial with TAU non-zero coefficients
    function _expandChallenge(bytes32 seed) private pure returns (uint256[N] memory) {
        uint256[N] memory c;

        // Use keccak256 to deterministically generate TAU positions for ±1
        bytes32 hash = seed;
        uint256 count = 0;
        uint256 index = 0;

        while (count < TAU && index < N) {
            hash = keccak256(abi.encodePacked(hash));
            uint256 pos = uint256(hash) % N;

            if (c[pos] == 0) {
                // Assign ±1 based on next bit
                c[pos] = (uint256(hash) & 1) == 0 ? 1 : Q - 1; // 1 or -1 (mod q)
                count++;
            }
            index++;
        }

        return c;
    }

    /// @notice Get algorithm parameters as a readable string
    /// @return Parameter string
    function getParameters() internal pure returns (string memory) {
        return "Dilithium3 (NIST Level 3): Q=8380417, K=6, L=5, eta=4, gamma1=2^19, gamma2=261888";
    }

    /// @notice Get signature size
    /// @return Size in bytes
    function getSignatureSize() internal pure returns (uint256) {
        return CRYPTO_BYTES;
    }

    /// @notice Get public key size
    /// @return Size in bytes
    function getPublicKeySize() internal pure returns (uint256) {
        return CRYPTO_PUBLICKEYBYTES;
    }
}

================
File: contracts/libraries/ZKVerifier.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/// @title ZKVerifier
/// @notice On-chain ZK-SNARK verifier for Dilithium signature proofs
/// @dev Verifies Groth16 proofs generated by off-chain API
contract ZKVerifier {
    // BN128 curve parameters
    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    struct VerifyingKey {
        Pairing.G1Point alfa1;
        Pairing.G2Point beta2;
        Pairing.G2Point gamma2;
        Pairing.G2Point delta2;
        Pairing.G1Point[] IC;
    }

    struct Proof {
        Pairing.G1Point A;
        Pairing.G2Point B;
        Pairing.G1Point C;
    }

    /// @notice Verify a ZK proof that a Dilithium signature is valid
    /// @param a Proof point A
    /// @param b Proof point B
    /// @param c Proof point C
    /// @param input Public inputs [messageHash, publicKeyHash]
    /// @return True if proof is valid
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[2] memory input
    ) public view returns (bool) {
        // Construct proof from input
        Proof memory proof;
        proof.A = Pairing.G1Point(a[0], a[1]);
        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);
        proof.C = Pairing.G1Point(c[0], c[1]);

        // Get verifying key
        VerifyingKey memory vk = verifyingKey();

        // Validate input length
        require(input.length + 1 == vk.IC.length, "Invalid input length");

        // Compute linear combination of inputs with IC
        Pairing.G1Point memory vk_x = vk.IC[0];
        for (uint256 i = 0; i < input.length; i++) {
            require(input[i] < PRIME_Q, "Input exceeds field modulus");
            vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[i + 1], input[i]));
        }

        // Verify pairing equation:
        // e(A, B) = e(alfa1, beta2) * e(vk_x, gamma2) * e(C, delta2)
        return Pairing.pairingProd4(
            Pairing.negate(proof.A), proof.B,
            vk.alfa1, vk.beta2,
            vk_x, vk.gamma2,
            proof.C, vk.delta2
        );
    }

    /// @notice Get the verifying key
    /// @dev This is generated from the trusted setup ceremony
    /// @return vk The verifying key
    function verifyingKey() internal pure returns (VerifyingKey memory vk) {
        // TODO: Replace with actual verifying key from circuit compilation
        // This is generated by: snarkjs zkey export verificationkey

        vk.alfa1 = Pairing.G1Point(
            uint256(0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef),
            uint256(0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321)
        );

        vk.beta2 = Pairing.G2Point(
            [uint256(0x1111111111111111111111111111111111111111111111111111111111111111),
             uint256(0x2222222222222222222222222222222222222222222222222222222222222222)],
            [uint256(0x3333333333333333333333333333333333333333333333333333333333333333),
             uint256(0x4444444444444444444444444444444444444444444444444444444444444444)]
        );

        vk.gamma2 = Pairing.G2Point(
            [uint256(0x5555555555555555555555555555555555555555555555555555555555555555),
             uint256(0x6666666666666666666666666666666666666666666666666666666666666666)],
            [uint256(0x7777777777777777777777777777777777777777777777777777777777777777),
             uint256(0x8888888888888888888888888888888888888888888888888888888888888888)]
        );

        vk.delta2 = Pairing.G2Point(
            [uint256(0x9999999999999999999999999999999999999999999999999999999999999999),
             uint256(0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)],
            [uint256(0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb),
             uint256(0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc)]
        );

        vk.IC = new Pairing.G1Point[](3);
        vk.IC[0] = Pairing.G1Point(
            uint256(0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd),
            uint256(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)
        );
        vk.IC[1] = Pairing.G1Point(
            uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff),
            uint256(0x0000000000000000000000000000000000000000000000000000000000000001)
        );
        vk.IC[2] = Pairing.G1Point(
            uint256(0x0000000000000000000000000000000000000000000000000000000000000002),
            uint256(0x0000000000000000000000000000000000000000000000000000000000000003)
        );
    }
}

/// @title Pairing
/// @notice Elliptic curve pairing operations on BN128
/// @dev Used for ZK-SNARK verification
library Pairing {
    struct G1Point {
        uint256 X;
        uint256 Y;
    }

    struct G2Point {
        uint256[2] X;
        uint256[2] Y;
    }

    /// @return The generator of G1
    function P1() internal pure returns (G1Point memory) {
        return G1Point(1, 2);
    }

    /// @return The generator of G2
    function P2() internal pure returns (G2Point memory) {
        return G2Point(
            [11559732032986387107991004021392285783925812861821192530917403151452391805634,
             10857046999023057135944570762232829481370756359578518086990519993285655852781],
            [4082367875863433681332203403145435568316851327593401208105741076214120093531,
             8495653923123431417604973247489272438418190587263600148770280649306958101930]
        );
    }

    /// @return The negation of p
    function negate(G1Point memory p) internal pure returns (G1Point memory) {
        uint256 PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
        if (p.X == 0 && p.Y == 0) {
            return G1Point(0, 0);
        }
        return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));
    }

    /// @return r = p + q
    function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {
        uint256[4] memory input;
        input[0] = p1.X;
        input[1] = p1.Y;
        input[2] = p2.X;
        input[3] = p2.Y;
        bool success;

        assembly {
            success := staticcall(sub(gas(), 2000), 6, input, 0x80, r, 0x40)
        }
        require(success, "EC addition failed");
    }

    /// @return r = p * s
    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {
        uint256[3] memory input;
        input[0] = p.X;
        input[1] = p.Y;
        input[2] = s;
        bool success;

        assembly {
            success := staticcall(sub(gas(), 2000), 7, input, 0x60, r, 0x40)
        }
        require(success, "EC scalar multiplication failed");
    }

    /// @return The result of computing the pairing check
    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {
        require(p1.length == p2.length, "Pairing length mismatch");
        uint256 elements = p1.length;
        uint256 inputSize = elements * 6;
        uint256[] memory input = new uint256[](inputSize);

        for (uint256 i = 0; i < elements; i++) {
            input[i * 6 + 0] = p1[i].X;
            input[i * 6 + 1] = p1[i].Y;
            input[i * 6 + 2] = p2[i].X[0];
            input[i * 6 + 3] = p2[i].X[1];
            input[i * 6 + 4] = p2[i].Y[0];
            input[i * 6 + 5] = p2[i].Y[1];
        }

        uint256[1] memory out;
        bool success;

        assembly {
            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)
        }
        require(success, "Pairing check failed");
        return out[0] != 0;
    }

    /// @return The result of e(p1[0], p2[0]) * ... * e(p1[n], p2[n]) == 1
    function pairingProd4(
        G1Point memory a1, G2Point memory a2,
        G1Point memory b1, G2Point memory b2,
        G1Point memory c1, G2Point memory c2,
        G1Point memory d1, G2Point memory d2
    ) internal view returns (bool) {
        G1Point[] memory p1 = new G1Point[](4);
        G2Point[] memory p2 = new G2Point[](4);
        p1[0] = a1;
        p1[1] = b1;
        p1[2] = c1;
        p1[3] = d1;
        p2[0] = a2;
        p2[1] = b2;
        p2[2] = c2;
        p2[3] = d2;
        return pairing(p1, p2);
    }
}

================
File: test/PQVault4626.t.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Test, console} from "forge-std/Test.sol";
import {PQVault4626} from "../contracts/vault/PQVault4626.sol";
import {ERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

/// @title MockERC20
/// @notice Mock ERC20 token for testing
contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MOCK") {
        _mint(msg.sender, 1000000 * 10 ** 18);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// @title PQVault4626Test
/// @notice Unit tests for PQVault4626 contract
contract PQVault4626Test is Test {
    PQVault4626 public vault;
    MockERC20 public token;

    address public user1 = address(0x1);
    address public user2 = address(0x2);
    address public owner = address(this);

    function setUp() public {
        // Deploy mock token
        token = new MockERC20();

        // Deploy vault
        vault = new PQVault4626(token, "PQ Vault Token", "vPQT");

        // Setup users with tokens
        token.mint(user1, 1000 ether);
        token.mint(user2, 1000 ether);

        vm.prank(user1);
        token.approve(address(vault), type(uint256).max);

        vm.prank(user2);
        token.approve(address(vault), type(uint256).max);
    }

    function test_DepositWithVesting() public {
        uint256 depositAmount = 100 ether;
        uint256 vestingBlocks = 2_628_000; // ~1 year at 12s/block (365 * 24 * 60 * 60 / 12)
        uint256 cliffBlocks = 216_000;     // ~30 days at 12s/block (30 * 24 * 60 * 60 / 12)

        vm.prank(user1);
        uint256 shares = vault.depositWithVesting(
            depositAmount,
            user1,
            vestingBlocks,
            cliffBlocks
        );

        assertTrue(shares > 0);

        (uint256 totalShares,,, uint256 cliffBlock, uint256 vestingEndBlock) = vault.getVestingInfo(user1);

        assertEq(totalShares, shares);
        assertEq(cliffBlock, block.number + cliffBlocks);
        assertEq(vestingEndBlock, block.number + vestingBlocks);
    }

    function test_WithdrawBeforeCliff() public {
        uint256 depositAmount = 100 ether;
        uint256 vestingBlocks = 2_628_000; // ~1 year
        uint256 cliffBlocks = 216_000;     // ~30 days

        vm.prank(user1);
        vault.depositWithVesting(depositAmount, user1, vestingBlocks, cliffBlocks);

        // Try to withdraw before cliff (advance 15 days worth of blocks)
        vm.roll(block.number + 108_000); // ~15 days

        vm.prank(user1);
        vm.expectRevert("Insufficient vested shares");
        vault.withdrawVested(1 ether);
    }

    function test_WithdrawAfterCliff() public {
        uint256 depositAmount = 100 ether;
        uint256 vestingBlocks = 2_628_000; // ~1 year
        uint256 cliffBlocks = 216_000;     // ~30 days

        vm.startPrank(user1);
        uint256 shares = vault.depositWithVesting(
            depositAmount,
            user1,
            vestingBlocks,
            cliffBlocks
        );

        // Advance blocks to halfway through vesting
        vm.roll(block.number + (vestingBlocks / 2));

        // Should be able to withdraw approximately half
        (, uint256 vestedShares, uint256 withdrawnShares,,) = vault.getVestingInfo(user1);

        uint256 withdrawable = vestedShares - withdrawnShares;
        assertTrue(withdrawable > 0);
        assertTrue(withdrawable < shares);

        vault.withdrawVested(withdrawable);
        vm.stopPrank();
    }

    function test_WithdrawFullyVested() public {
        uint256 depositAmount = 100 ether;
        uint256 vestingBlocks = 2_628_000; // ~1 year
        uint256 cliffBlocks = 216_000;     // ~30 days

        vm.startPrank(user1);
        uint256 shares = vault.depositWithVesting(
            depositAmount,
            user1,
            vestingBlocks,
            cliffBlocks
        );

        // Advance blocks past vesting end
        vm.roll(block.number + vestingBlocks + 7200); // +1 day of blocks

        // Should be able to withdraw everything
        vault.withdrawVested(shares);
        vm.stopPrank();

        (, uint256 vestedShares, uint256 withdrawnShares,,) = vault.getVestingInfo(user1);
        assertEq(vestedShares, withdrawnShares);
    }

    function test_RegularDeposit() public {
        uint256 depositAmount = 100 ether;

        vm.prank(user1);
        uint256 shares = vault.deposit(depositAmount, user1);

        assertEq(vault.balanceOf(user1), shares);
    }

    function test_Pause() public {
        vault.pause();

        vm.prank(user1);
        vm.expectRevert();
        vault.deposit(100 ether, user1);
    }

    function test_Unpause() public {
        vault.pause();
        vault.unpause();

        vm.prank(user1);
        vault.deposit(100 ether, user1);
    }
}

================
File: test/PQWallet.t.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Test, console} from "forge-std/Test.sol";
import {PQWallet} from "../contracts/core/PQWallet.sol";
import {PQWalletFactory} from "../contracts/core/PQWalletFactory.sol";
import {PQValidator} from "../contracts/core/PQValidator.sol";
import {IEntryPoint} from "lib/account-abstraction/contracts/interfaces/IEntryPoint.sol";
import {PackedUserOperation} from "lib/account-abstraction/contracts/interfaces/PackedUserOperation.sol";

/// @title PQWalletTest
/// @notice Unit tests for PQWallet contract
contract PQWalletTest is Test {
    PQWalletFactory public factory;
    PQWallet public wallet;
    PQValidator public validator;

    // Mock EntryPoint address (Base Sepolia)
    IEntryPoint public entryPoint = IEntryPoint(0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789);

    // Test PQ public key (32 bytes for testing)
    bytes public pqPublicKey = hex"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

    address public user = address(0x1);
    address public target = address(0x2);

    function setUp() public {
        // Deploy validator
        validator = new PQValidator();

        // Deploy factory
        factory = new PQWalletFactory(entryPoint, validator);

        // Create wallet (use salt = 1, as 0 is not allowed for security)
        vm.prank(user);
        wallet = PQWallet(payable(factory.createWallet(pqPublicKey, 1)));

        // Fund wallet with ETH
        vm.deal(address(wallet), 10 ether);
        vm.deal(user, 10 ether);
    }

    function test_CreateWallet() public view {
        assertEq(wallet.getPQPublicKey(), pqPublicKey);
        assertEq(address(wallet.validator()), address(validator));
        assertEq(address(wallet.entryPoint()), address(entryPoint));
    }

    function test_GetAddress() public view {
        address predicted = factory.getAddress(pqPublicKey, 1);
        assertEq(predicted, address(wallet));
    }

    function test_CreateWalletIdempotent() public {
        vm.prank(user);
        address wallet2 = factory.createWallet(pqPublicKey, 1);
        assertEq(wallet2, address(wallet));
    }

    function test_Execute() public {
        bytes memory data = abi.encodeWithSignature("someFunction()");

        vm.prank(address(wallet));
        wallet.execute(target, 1 ether, data);

        assertEq(target.balance, 1 ether);
    }

    function test_ExecuteBatch() public {
        address[] memory targets = new address[](2);
        targets[0] = target;
        targets[1] = address(0x3);

        uint256[] memory values = new uint256[](2);
        values[0] = 1 ether;
        values[1] = 2 ether;

        bytes[] memory datas = new bytes[](2);
        datas[0] = "";
        datas[1] = "";

        vm.prank(address(wallet));
        wallet.executeBatch(targets, values, datas);

        assertEq(target.balance, 1 ether);
        assertEq(address(0x3).balance, 2 ether);
    }

    function test_RevertExecuteUnauthorized() public {
        bytes memory data = "";

        vm.prank(user);
        vm.expectRevert("Only owner");
        wallet.execute(target, 0, data);
    }

    function test_UpdatePQPublicKey() public {
        bytes memory newKey = hex"fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210";

        vm.prank(address(wallet));
        wallet.updatePQPublicKey(newKey);

        assertEq(wallet.getPQPublicKey(), newKey);
    }

    function test_RevertUpdatePQPublicKeyUnauthorized() public {
        bytes memory newKey = hex"fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210";

        vm.prank(user);
        vm.expectRevert("Only owner");
        wallet.updatePQPublicKey(newKey);
    }

    function test_ReceiveEther() public {
        vm.prank(user);
        (bool success,) = address(wallet).call{value: 1 ether}("");
        assertTrue(success);
        assertEq(address(wallet).balance, 11 ether);
    }
}

================
File: contracts/core/PQValidator.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {IPQValidator} from "../interfaces/IPQValidator.sol";
import {DilithiumVerifier} from "../libraries/DilithiumVerifier.sol";
import {ZKVerifier} from "../libraries/ZKVerifier.sol";
import {Ownable} from "lib/openzeppelin-contracts/contracts/access/Ownable.sol";

/// @title PQValidator
/// @notice Post-Quantum signature validator for SPHINCS+ and Dilithium
/// @dev Supports both on-chain and ZK-proof verification modes
contract PQValidator is IPQValidator, Ownable {
    /// @notice Verification mode
    enum VerificationMode {
        ON_CHAIN,      // Full on-chain verification (expensive gas)
        ZK_PROOF,      // ZK-SNARK proof verification (cheap gas)
        HYBRID         // Try ZK first, fallback to on-chain
    }

    /// @notice Current verification mode
    VerificationMode public verificationMode;

    /// @notice ZK verifier contract
    ZKVerifier public zkVerifier;

    /// @notice Authorized wallets that can use this validator
    mapping(address => bool) public authorizedWallets;

    /// @notice If true, only authorized wallets can verify signatures
    bool public requireAuthorization;

    /// @notice Emitted when verification mode changes
    event VerificationModeChanged(VerificationMode oldMode, VerificationMode newMode);

    /// @notice Emitted when ZK verifier is updated
    event ZKVerifierUpdated(address oldVerifier, address newVerifier);

    /// @notice Emitted when wallet authorization changes
    event WalletAuthorizationChanged(address indexed wallet, bool authorized);

    /// @notice Emitted when authorization requirement changes
    event AuthorizationRequirementChanged(bool required);

    /// @notice Only authorized wallets can call
    modifier onlyAuthorized() {
        if (requireAuthorization) {
            require(authorizedWallets[msg.sender], "Wallet not authorized");
        }
        _;
    }

    constructor() Ownable(msg.sender) {
        verificationMode = VerificationMode.ZK_PROOF;
        requireAuthorization = false; // Start permissionless for testing
    }
    /// @notice Verify a post-quantum signature (defaults to SPHINCS+)
    /// @param message The message that was signed
    /// @param signature The post-quantum signature
    /// @param publicKey The post-quantum public key
    /// @return True if signature is valid
    function verifySignature(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) external view override onlyAuthorized returns (bool) {
        return verifySPHINCSPlus(message, signature, publicKey);
    }

    /// @notice Verify a SPHINCS+ signature
    /// @dev PLACEHOLDER: Production implementation requires:
    ///      1. Optimized SPHINCS+ library in Solidity
    ///      2. EVM precompile for gas efficiency
    ///      3. Or ZK proof of signature validity
    /// @param message The message that was signed
    /// @param signature The SPHINCS+ signature (typically ~7-8KB for 128-bit security)
    /// @param publicKey The SPHINCS+ public key (typically 32-64 bytes)
    /// @return True if signature is valid
    function verifySPHINCSPlus(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) public pure override returns (bool) {
        // CRITICAL: This is a placeholder for development/testing only
        // A real implementation would:
        // 1. Parse the SPHINCS+ signature components
        // 2. Rebuild the Merkle tree path
        // 3. Verify FORS (Forest of Random Subsets) signature
        // 4. Verify WOTS+ (Winternitz One-Time Signature)
        // 5. Verify hypertree authentication path

        // For now, basic length validation to prevent completely invalid inputs
        require(message.length > 0, "Empty message");
        require(signature.length >= 64, "Signature too short");
        require(publicKey.length >= 32, "Public key too short");

        // TODO: Implement actual SPHINCS+ verification
        // This would be gas-prohibitive in pure Solidity
        // Recommended approaches:
        // - Use EVM precompile (requires network support)
        // - Use ZK-SNARK proof of valid signature
        // - Use optimized assembly implementation

        // TEMPORARY: For development, accept any properly sized signature
        // This allows testing of the overall architecture
        return signature.length >= 64 && publicKey.length >= 32;
    }

    /// @notice Verify a Dilithium signature
    /// @dev Chooses verification method based on current mode
    /// @param message The message that was signed
    /// @param signature The Dilithium signature (3293 bytes) OR ZK proof
    /// @param publicKey The Dilithium public key (1952 bytes for Dilithium3)
    /// @return True if signature is valid
    function verifyDilithium(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) public view override returns (bool) {
        if (verificationMode == VerificationMode.ON_CHAIN) {
            // Full on-chain Dilithium verification
            // WARNING: This is gas-expensive (~10M gas)
            return DilithiumVerifier.verify(message, signature, publicKey);
        }

        else if (verificationMode == VerificationMode.ZK_PROOF) {
            // ZK-SNARK proof verification (~250k gas)
            return _verifyZKProof(message, signature, publicKey);
        }

        else if (verificationMode == VerificationMode.HYBRID) {
            // Try ZK proof first, fallback to on-chain if needed
            try this.verifyDilithium(message, signature, publicKey) returns (bool result) {
                return result;
            } catch {
                return DilithiumVerifier.verify(message, signature, publicKey);
            }
        }

        return false;
    }

    /// @notice Verify ZK proof of valid Dilithium signature
    /// @param message The message that was signed
    /// @param zkProof The ZK-SNARK proof (generated off-chain)
    /// @param publicKey The Dilithium public key
    /// @return True if proof is valid
    function _verifyZKProof(
        bytes memory message,
        bytes memory zkProof,
        bytes memory publicKey
    ) internal view returns (bool) {
        require(address(zkVerifier) != address(0), "ZK verifier not set");

        // Parse ZK proof components
        // Format: [a_x, a_y, b_x0, b_x1, b_y0, b_y1, c_x, c_y, messageHash, publicKeyHash]
        require(zkProof.length >= 320, "Invalid ZK proof length");

        uint256[2] memory a;
        uint256[2][2] memory b;
        uint256[2] memory c;
        uint256[2] memory input;

        assembly {
            let ptr := add(zkProof, 32)
            mstore(a, mload(ptr))
            mstore(add(a, 32), mload(add(ptr, 32)))

            mstore(mload(b), mload(add(ptr, 64)))
            mstore(add(mload(b), 32), mload(add(ptr, 96)))
            mstore(mload(add(b, 32)), mload(add(ptr, 128)))
            mstore(add(mload(add(b, 32)), 32), mload(add(ptr, 160)))

            mstore(c, mload(add(ptr, 192)))
            mstore(add(c, 32), mload(add(ptr, 224)))

            mstore(input, mload(add(ptr, 256)))
            mstore(add(input, 32), mload(add(ptr, 288)))
        }

        // Verify the proof
        return zkVerifier.verifyProof(a, b, c, input);
    }

    /// @notice Set verification mode (admin only)
    /// @param mode New verification mode
    function setVerificationMode(VerificationMode mode) external onlyOwner {
        VerificationMode oldMode = verificationMode;
        verificationMode = mode;
        emit VerificationModeChanged(oldMode, mode);
    }

    /// @notice Set ZK verifier contract (admin only)
    /// @param _zkVerifier Address of ZK verifier contract
    function setZKVerifier(address _zkVerifier) external onlyOwner {
        require(_zkVerifier != address(0), "Invalid address");
        address oldVerifier = address(zkVerifier);
        zkVerifier = ZKVerifier(_zkVerifier);
        emit ZKVerifierUpdated(oldVerifier, _zkVerifier);
    }

    /// @notice Get current verification mode as string
    /// @return Mode name
    function getVerificationModeName() external view returns (string memory) {
        if (verificationMode == VerificationMode.ON_CHAIN) return "ON_CHAIN";
        if (verificationMode == VerificationMode.ZK_PROOF) return "ZK_PROOF";
        if (verificationMode == VerificationMode.HYBRID) return "HYBRID";
        return "UNKNOWN";
    }

    /// @notice Get supported PQ algorithms
    /// @return Array of supported algorithm names
    function getSupportedAlgorithms() external pure returns (string[] memory) {
        string[] memory algorithms = new string[](2);
        algorithms[0] = "SPHINCS+-SHA2-128f";
        algorithms[1] = "Dilithium3";
        return algorithms;
    }

    // ============ Access Control Management ============

    /// @notice Authorize a wallet to use this validator
    /// @param wallet Address of the wallet to authorize
    function authorizeWallet(address wallet) external onlyOwner {
        require(wallet != address(0), "Invalid wallet address");
        authorizedWallets[wallet] = true;
        emit WalletAuthorizationChanged(wallet, true);
    }

    /// @notice Revoke wallet authorization
    /// @param wallet Address of the wallet to revoke
    function revokeWallet(address wallet) external onlyOwner {
        authorizedWallets[wallet] = false;
        emit WalletAuthorizationChanged(wallet, false);
    }

    /// @notice Authorize multiple wallets at once
    /// @param wallets Array of wallet addresses to authorize
    function authorizeWalletsBatch(address[] calldata wallets) external onlyOwner {
        for (uint256 i = 0; i < wallets.length; i++) {
            require(wallets[i] != address(0), "Invalid wallet address");
            authorizedWallets[wallets[i]] = true;
            emit WalletAuthorizationChanged(wallets[i], true);
        }
    }

    /// @notice Enable or disable authorization requirement
    /// @param required If true, only authorized wallets can verify signatures
    function setAuthorizationRequired(bool required) external onlyOwner {
        requireAuthorization = required;
        emit AuthorizationRequirementChanged(required);
    }

    /// @notice Check if a wallet is authorized
    /// @param wallet Address to check
    /// @return True if wallet is authorized (or if authorization not required)
    function isAuthorized(address wallet) external view returns (bool) {
        if (!requireAuthorization) {
            return true; // Permissionless mode
        }
        return authorizedWallets[wallet];
    }
}

================
File: contracts/core/PQWallet.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {IPQWallet} from "../interfaces/IPQWallet.sol";
import {IPQValidator} from "../interfaces/IPQValidator.sol";
import {PackedUserOperation} from "lib/account-abstraction/contracts/interfaces/PackedUserOperation.sol";
import {IAccount} from "lib/account-abstraction/contracts/interfaces/IAccount.sol";
import {IEntryPoint} from "lib/account-abstraction/contracts/interfaces/IEntryPoint.sol";
import {ReentrancyGuard} from "lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol";
import {PQConstants} from "../libraries/PQConstants.sol";

/// @title PQWallet
/// @notice Post-Quantum secure ERC-4337 compatible smart contract wallet
/// @dev Uses SPHINCS+ or Dilithium for signature validation
contract PQWallet is IPQWallet, IAccount, ReentrancyGuard {
    /// @notice The EntryPoint contract (ERC-4337 singleton)
    IEntryPoint public immutable entryPoint;

    /// @notice The PQ signature validator contract
    IPQValidator private immutable _validator;

    /// @notice Returns the address of the PQ validator
    function validator() external view override returns (address) {
        return address(_validator);
    }

    /// @notice The post-quantum public key for this wallet
    bytes public pqPublicKey;

    /// @notice Nonce for replay protection
    uint256 public nonce;

    /// @notice ERC-4337 signature validation failed magic value
    uint256 private constant SIG_VALIDATION_FAILED = 1;

    /// @notice Only allow calls from EntryPoint
    modifier onlyEntryPoint() {
        require(msg.sender == address(entryPoint), "Only EntryPoint");
        _;
    }

    /// @notice Only allow calls from this wallet or EntryPoint
    modifier onlyOwner() {
        require(msg.sender == address(this) || msg.sender == address(entryPoint), "Only owner");
        _;
    }

    /// @notice Constructor
    /// @param _entryPoint The ERC-4337 EntryPoint address
    /// @param _validator The PQ validator address
    /// @param _pqPublicKey The initial post-quantum public key
    constructor(
        IEntryPoint _entryPoint,
        IPQValidator _validator,
        bytes memory _pqPublicKey
    ) {
        require(address(_entryPoint) != address(0), "Invalid EntryPoint");
        require(address(_validator) != address(0), "Invalid validator");

        // NIST-compliant PQ key size validation
        require(
            PQConstants.isValidPublicKeySize(_pqPublicKey.length),
            "Invalid PQ public key size - must be NIST-compliant"
        );

        entryPoint = _entryPoint;
        _validator = _validator;
        pqPublicKey = _pqPublicKey;
    }

    /// @notice Receive ETH
    receive() external payable {}

    /// @notice Returns the post-quantum public key
    function getPQPublicKey() external view override returns (bytes memory) {
        return pqPublicKey;
    }

    /// @notice Execute a transaction from this wallet
    /// @param target The target contract address
    /// @param value The amount of ETH to send
    /// @param data The calldata to execute
    function execute(
        address target,
        uint256 value,
        bytes calldata data
    ) external override onlyOwner nonReentrant {
        _execute(target, value, data);
    }

    /// @notice Execute a batch of transactions
    /// @param targets Array of target addresses
    /// @param values Array of ETH amounts
    /// @param datas Array of calldata
    function executeBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external override onlyOwner nonReentrant {
        require(targets.length > 0, "Empty batch");
        require(targets.length <= 256, "Batch too large"); // Prevent gas exhaustion
        require(targets.length == values.length, "Length mismatch");
        require(targets.length == datas.length, "Length mismatch");

        for (uint256 i = 0; i < targets.length; i++) {
            _execute(targets[i], values[i], datas[i]);
        }
    }

    /// @notice Internal execute function
    /// @param target The target contract address
    /// @param value The amount of ETH to send
    /// @param data The calldata to execute
    function _execute(address target, uint256 value, bytes calldata data) internal {
        require(target != address(0), "Invalid target");

        (bool success, bytes memory result) = target.call{value: value}(data);
        if (!success) {
            assembly {
                revert(add(result, 32), mload(result))
            }
        }

        emit Executed(target, value, data);
    }

    /// @notice Validate a user operation (ERC-4337)
    /// @param userOp The user operation to validate
    /// @param userOpHash Hash of the user operation
    /// @param missingAccountFunds Amount of funds missing to pay for the operation
    /// @return validationData 0 if valid, 1 if invalid
    function validateUserOp(
        PackedUserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 missingAccountFunds
    ) external override(IAccount, IPQWallet) onlyEntryPoint returns (uint256 validationData) {
        // ERC-4337 calldata validation (protect against malformed data)
        bytes memory signature = userOp.signature;

        // Validate signature is not empty and within reasonable bounds
        require(signature.length > 0, "Empty signature");
        require(signature.length <= 10000, "Signature too large"); // Prevent DoS
        require(signature.length >= 64, "Signature too short"); // Minimum for any valid PQ sig

        // Validate userOpHash is not zero (indicates malformed userOp)
        require(userOpHash != bytes32(0), "Invalid userOp hash");

        // Validate nonce is reasonable (prevent replay with manipulated nonce)
        uint256 currentNonce = entryPoint.getNonce(address(this), 0);
        require(currentNonce < type(uint192).max, "Nonce overflow");

        bytes32 hash = _getEthSignedMessageHash(userOpHash);

        bool isValid = _validator.verifySignature(
            abi.encodePacked(hash),
            signature,
            pqPublicKey
        );

        // Pay the EntryPoint if needed
        if (missingAccountFunds > 0) {
            // Validate payment amount is reasonable
            require(missingAccountFunds <= address(this).balance, "Insufficient balance");
            require(missingAccountFunds <= 10 ether, "Payment too large"); // Sanity check

            (bool success,) = payable(msg.sender).call{value: missingAccountFunds}("");
            require(success, "Payment failed");
        }

        return isValid ? 0 : SIG_VALIDATION_FAILED;
    }

    /// @notice Get the hash in the Ethereum signed message format
    /// @param _messageHash The message hash
    /// @return The Ethereum signed message hash
    function _getEthSignedMessageHash(bytes32 _messageHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _messageHash));
    }

    /// @notice Update the post-quantum public key (only callable by wallet itself)
    /// @param newPqPublicKey The new PQ public key
    function updatePQPublicKey(bytes memory newPqPublicKey) external onlyOwner {
        // NIST-compliant PQ key size validation
        require(
            PQConstants.isValidPublicKeySize(newPqPublicKey.length),
            "Invalid PQ public key size - must be NIST-compliant"
        );
        require(keccak256(newPqPublicKey) != keccak256(pqPublicKey), "Key unchanged");

        bytes memory oldKey = pqPublicKey;
        pqPublicKey = newPqPublicKey;

        emit PQPublicKeyUpdated(oldKey, newPqPublicKey);
    }

    /// @notice Get the nonce for this wallet
    /// @return The current nonce
    function getNonce() external view returns (uint256) {
        return entryPoint.getNonce(address(this), 0);
    }
}

================
File: contracts/core/PQWalletFactory.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {PQWallet} from "./PQWallet.sol";
import {IPQValidator} from "../interfaces/IPQValidator.sol";
import {IEntryPoint} from "lib/account-abstraction/contracts/interfaces/IEntryPoint.sol";
import {Create2} from "lib/openzeppelin-contracts/contracts/utils/Create2.sol";
import {Ownable} from "lib/openzeppelin-contracts/contracts/access/Ownable.sol";
import {PQConstants} from "../libraries/PQConstants.sol";

/// @title PQWalletFactory
/// @notice Factory for deploying Post-Quantum secure wallets using CREATE2
/// @dev Allows deterministic wallet addresses for counterfactual deployment
contract PQWalletFactory is Ownable {
    /// @notice The EntryPoint contract
    IEntryPoint public immutable entryPoint;

    /// @notice The PQ validator contract
    IPQValidator private immutable _validator;

    /// @notice Returns the PQ validator address
    function validator() external view returns (address) {
        return address(_validator);
    }

    /// @notice Emitted when a new wallet is created
    event WalletCreated(
        address indexed wallet,
        bytes pqPublicKey,
        uint256 salt
    );

    /// @notice Constructor
    /// @param _entryPoint The ERC-4337 EntryPoint address
    /// @param _validator The PQ validator address
    constructor(IEntryPoint _entryPoint, IPQValidator _validator) Ownable(msg.sender) {
        require(address(_entryPoint) != address(0), "Invalid EntryPoint");
        require(address(_validator) != address(0), "Invalid validator");

        entryPoint = _entryPoint;
        _validator = _validator;
    }

    /// @notice Create a new PQ wallet
    /// @param pqPublicKey The post-quantum public key for the wallet
    /// @param salt Salt for CREATE2 (allows multiple wallets per PQ key)
    /// @return wallet The address of the created wallet
    function createWallet(
        bytes memory pqPublicKey,
        uint256 salt
    ) external returns (address wallet) {
        // NIST-compliant PQ key size validation
        require(
            PQConstants.isValidPublicKeySize(pqPublicKey.length),
            "Invalid PQ public key size - must be NIST-compliant"
        );

        // Enhance salt with additional entropy to prevent predictable addresses
        require(salt != 0, "Salt cannot be zero");
        bytes32 enhancedSalt = keccak256(abi.encodePacked(
            msg.sender,
            block.timestamp,
            block.prevrandao, // Post-Merge randomness
            salt,
            pqPublicKey
        ));

        // Get the predicted address
        address predictedAddress = getAddress(pqPublicKey, uint256(enhancedSalt));

        // Check if wallet already exists
        if (predictedAddress.code.length > 0) {
            return predictedAddress;
        }

        // Deploy wallet using CREATE2
        bytes32 create2Salt = _getSalt(pqPublicKey, uint256(enhancedSalt));
        wallet = address(
            new PQWallet{salt: create2Salt}(
                entryPoint,
                _validator,
                pqPublicKey
            )
        );

        require(wallet == predictedAddress, "Address mismatch");

        emit WalletCreated(wallet, pqPublicKey, salt);
    }

    /// @notice Get the counterfactual address for a wallet
    /// @param pqPublicKey The post-quantum public key
    /// @param salt Salt for CREATE2
    /// @return The predicted wallet address
    function getAddress(
        bytes memory pqPublicKey,
        uint256 salt
    ) public view returns (address) {
        bytes32 create2Salt = _getSalt(pqPublicKey, salt);
        bytes memory bytecode = _getWalletBytecode(pqPublicKey);

        return Create2.computeAddress(create2Salt, keccak256(bytecode));
    }

    /// @notice Get the creation bytecode for a wallet
    /// @param pqPublicKey The post-quantum public key
    /// @return The bytecode for deploying the wallet
    function _getWalletBytecode(bytes memory pqPublicKey) internal view returns (bytes memory) {
        return abi.encodePacked(
            type(PQWallet).creationCode,
            abi.encode(entryPoint, _validator, pqPublicKey)
        );
    }

    /// @notice Get the CREATE2 salt
    /// @param pqPublicKey The post-quantum public key
    /// @param salt User-provided salt
    /// @return The CREATE2 salt
    function _getSalt(bytes memory pqPublicKey, uint256 salt) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(pqPublicKey, salt));
    }

    /// @notice Add stake to EntryPoint (for factory reputation)
    /// @param unstakeDelaySec Unstake delay in seconds
    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {
        require(msg.value > 0, "Must stake non-zero amount");
        entryPoint.addStake{value: msg.value}(unstakeDelaySec);
    }

    /// @notice Unlock stake from EntryPoint
    function unlockStake() external onlyOwner {
        entryPoint.unlockStake();
    }

    /// @notice Withdraw stake from EntryPoint
    /// @param withdrawAddress Address to receive the stake
    function withdrawStake(address payable withdrawAddress) external onlyOwner {
        require(withdrawAddress != address(0), "Invalid withdraw address");
        entryPoint.withdrawStake(withdrawAddress);
    }
}

================
File: contracts/oracles/QRNGOracle.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title QRNGOracle
 * @notice Quantum Random Number Generator Oracle
 * @dev Provides cryptographically secure quantum random numbers from ANU Quantum Random Numbers Server
 *
 * Quantum Source: Australian National University (ANU) QRNG API
 * - Uses quantum vacuum fluctuations measured with homodyne detection
 * - True randomness from quantum mechanics (not pseudo-random)
 * - Published research: https://qrng.anu.edu.au/
 *
 * Similar to Chainlink VRF but with quantum randomness source
 *
 * Usage Flow:
 * 1. Consumer calls requestRandomness() with payment
 * 2. Oracle listens for RandomnessRequested event
 * 3. Oracle fetches quantum random from ANU QRNG API
 * 4. Oracle submits via fulfillRandomness()
 * 5. Consumer's callback is triggered with random number
 */
contract QRNGOracle is Ownable, ReentrancyGuard, Pausable {
    // ============ State Variables ============

    /// @notice Fee per randomness request
    uint256 public randomnessFee = 0.0005 ether;

    /// @notice Oracle operators authorized to fulfill requests
    mapping(address => bool) public operators;

    /// @notice Request tracking
    mapping(bytes32 => RandomnessRequest) public requests;

    /// @notice Subscription balances (prepaid model)
    mapping(address => uint256) public subscriptions;

    /// @notice Whitelisted addresses that can use oracle for free
    mapping(address => bool) public freeUsers;

    /// @notice Used request IDs for replay protection
    mapping(bytes32 => bool) public usedRequestIds;

    /// @notice Request expiration time (default 1 hour)
    uint256 public requestExpiration = 1 hours;

    /// @notice Number of random bytes per request
    uint256 public constant RANDOM_BYTES = 32; // 256 bits

    /// @notice Total revenue collected
    uint256 public totalRevenue;

    /// @notice Nonce for request ID generation
    uint256 private nonce;

    // ============ Structs & Enums ============

    enum RequestStatus {
        Pending,
        Fulfilled,
        Failed
    }

    struct RandomnessRequest {
        address requester;
        uint256 timestamp;
        RequestStatus status;
        uint256 randomness; // 256-bit quantum random number
        bytes32 seed; // Optional user seed for additional entropy
    }

    // ============ Events ============

    event RandomnessRequested(
        bytes32 indexed requestId,
        address indexed requester,
        bytes32 seed
    );

    event RandomnessFulfilled(
        bytes32 indexed requestId,
        address indexed requester,
        uint256 randomness
    );

    event RandomnessFailed(bytes32 indexed requestId, string reason);

    event OperatorAdded(address indexed operator);
    event OperatorRemoved(address indexed operator);
    event FeeUpdated(uint256 oldFee, uint256 newFee);
    event SubscriptionDeposit(address indexed subscriber, uint256 amount);
    event SubscriptionWithdrawal(address indexed subscriber, uint256 amount);
    event FreeUserAdded(address indexed user);
    event FreeUserRemoved(address indexed user);

    // ============ Errors ============

    error InsufficientPayment();
    error UnauthorizedOperator();
    error InvalidRequestStatus();
    error InsufficientSubscription();
    error InvalidRandomness();

    // ============ Constructor ============

    constructor() Ownable(msg.sender) {
        operators[msg.sender] = true;
    }

    // ============ Core Functions ============

    /**
     * @notice Request quantum random number (pay-per-use)
     * @param seed Optional user-provided seed for additional entropy
     * @return requestId Unique identifier for this randomness request
     */
    function requestRandomness(bytes32 seed) external payable nonReentrant whenNotPaused returns (bytes32 requestId) {
        // Check if user is whitelisted for free usage
        if (!freeUsers[msg.sender]) {
            if (msg.value < randomnessFee) revert InsufficientPayment();
            totalRevenue += randomnessFee;
        }

        requestId = keccak256(
            abi.encodePacked(
                msg.sender,
                block.timestamp,
                block.number,
                nonce++,
                seed
            )
        );

        requests[requestId] = RandomnessRequest({
            requester: msg.sender,
            timestamp: block.timestamp,
            status: RequestStatus.Pending,
            randomness: 0,
            seed: seed
        });

        emit RandomnessRequested(requestId, msg.sender, seed);

        // Refund excess payment
        if (msg.value > randomnessFee) {
            payable(msg.sender).transfer(msg.value - randomnessFee);
        }

        return requestId;
    }

    /**
     * @notice Request randomness using subscription
     * @param seed Optional user-provided seed
     * @return requestId Unique identifier
     */
    function requestRandomnessWithSubscription(bytes32 seed) external nonReentrant whenNotPaused returns (bytes32 requestId) {
        if (subscriptions[msg.sender] < randomnessFee) revert InsufficientSubscription();

        subscriptions[msg.sender] -= randomnessFee;
        totalRevenue += randomnessFee;

        requestId = keccak256(
            abi.encodePacked(
                msg.sender,
                block.timestamp,
                block.number,
                nonce++,
                seed
            )
        );

        requests[requestId] = RandomnessRequest({
            requester: msg.sender,
            timestamp: block.timestamp,
            status: RequestStatus.Pending,
            randomness: 0,
            seed: seed
        });

        emit RandomnessRequested(requestId, msg.sender, seed);

        return requestId;
    }

    /**
     * @notice Fulfill randomness request (called by oracle operator)
     * @param requestId The request ID
     * @param randomness The quantum random number from ANU QRNG
     */
    function fulfillRandomness(
        bytes32 requestId,
        uint256 randomness
    ) external nonReentrant {
        if (!operators[msg.sender]) revert UnauthorizedOperator();

        RandomnessRequest storage request = requests[requestId];
        if (request.status != RequestStatus.Pending) revert InvalidRequestStatus();
        if (randomness == 0) revert InvalidRandomness();

        // Replay protection
        require(!usedRequestIds[requestId], "Request already fulfilled");

        // Expiration check
        require(
            block.timestamp < request.timestamp + requestExpiration,
            "Request expired"
        );

        usedRequestIds[requestId] = true;

        // Mix with user seed if provided
        if (request.seed != bytes32(0)) {
            randomness = uint256(keccak256(abi.encodePacked(randomness, request.seed)));
        }

        request.randomness = randomness;
        request.status = RequestStatus.Fulfilled;

        emit RandomnessFulfilled(requestId, request.requester, randomness);

        // Callback to consumer
        try IRandomnessConsumer(request.requester).handleRandomness(requestId, randomness) {
            // Success
        } catch {
            // Consumer doesn't implement callback, that's ok
        }
    }

    /**
     * @notice Mark request as failed and refund
     * @param requestId The request ID
     * @param reason Failure reason
     */
    function markRandomnessFailed(bytes32 requestId, string calldata reason) external {
        if (!operators[msg.sender]) revert UnauthorizedOperator();

        RandomnessRequest storage request = requests[requestId];
        if (request.status != RequestStatus.Pending) revert InvalidRequestStatus();

        request.status = RequestStatus.Failed;

        emit RandomnessFailed(requestId, reason);

        // Refund the fee
        payable(request.requester).transfer(randomnessFee);
    }

    // ============ Batch Randomness (for efficiency) ============

    /**
     * @notice Request multiple random numbers at once
     * @param count Number of random numbers needed
     * @param seed User seed
     * @return requestIds Array of request IDs
     */
    function requestMultipleRandomness(
        uint256 count,
        bytes32 seed
    ) external payable nonReentrant whenNotPaused returns (bytes32[] memory requestIds) {
        uint256 totalFee = randomnessFee * count;
        if (msg.value < totalFee) revert InsufficientPayment();

        requestIds = new bytes32[](count);

        for (uint256 i = 0; i < count; i++) {
            bytes32 requestId = keccak256(
                abi.encodePacked(
                    msg.sender,
                    block.timestamp,
                    block.number,
                    nonce++,
                    seed,
                    i
                )
            );

            requests[requestId] = RandomnessRequest({
                requester: msg.sender,
                timestamp: block.timestamp,
                status: RequestStatus.Pending,
                randomness: 0,
                seed: seed
            });

            requestIds[i] = requestId;
            emit RandomnessRequested(requestId, msg.sender, seed);
        }

        totalRevenue += totalFee;

        // Refund excess
        if (msg.value > totalFee) {
            payable(msg.sender).transfer(msg.value - totalFee);
        }

        return requestIds;
    }

    // ============ Subscription Management ============

    /**
     * @notice Deposit for subscription
     */
    function subscribe() external payable {
        subscriptions[msg.sender] += msg.value;
        emit SubscriptionDeposit(msg.sender, msg.value);
    }

    /**
     * @notice Withdraw subscription balance
     * @param amount Amount to withdraw
     */
    function withdrawSubscription(uint256 amount) external nonReentrant {
        if (subscriptions[msg.sender] < amount) revert InsufficientSubscription();

        subscriptions[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);

        emit SubscriptionWithdrawal(msg.sender, amount);
    }

    // ============ Admin Functions ============

    /**
     * @notice Add a user to the free usage whitelist (e.g., your own apps)
     * @param user Address to whitelist
     */
    function addFreeUser(address user) external onlyOwner {
        freeUsers[user] = true;
        emit FreeUserAdded(user);
    }

    /**
     * @notice Remove a user from the free usage whitelist
     * @param user Address to remove
     */
    function removeFreeUser(address user) external onlyOwner {
        freeUsers[user] = false;
        emit FreeUserRemoved(user);
    }

    function addOperator(address operator) external onlyOwner {
        operators[operator] = true;
        emit OperatorAdded(operator);
    }

    function removeOperator(address operator) external onlyOwner {
        operators[operator] = false;
        emit OperatorRemoved(operator);
    }

    function setRandomnessFee(uint256 newFee) external onlyOwner {
        require(newFee <= 0.1 ether, "Fee too high"); // Max 0.1 ETH
        uint256 oldFee = randomnessFee;
        randomnessFee = newFee;
        emit FeeUpdated(oldFee, newFee);
    }

    /**
     * @notice Update request expiration time
     * @param newExpiration New expiration in seconds
     */
    function setRequestExpiration(uint256 newExpiration) external onlyOwner {
        require(newExpiration >= 5 minutes, "Expiration too short");
        require(newExpiration <= 24 hours, "Expiration too long");
        requestExpiration = newExpiration;
    }

    function withdrawRevenue(uint256 amount) external onlyOwner {
        require(amount <= totalRevenue, "Insufficient revenue");
        totalRevenue -= amount;
        payable(owner()).transfer(amount);
    }

    /**
     * @notice Pause the oracle in case of emergency
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @notice Unpause the oracle
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    // ============ View Functions ============

    function getRequest(bytes32 requestId) external view returns (RandomnessRequest memory) {
        return requests[requestId];
    }

    function isRequestFulfilled(bytes32 requestId) external view returns (bool) {
        return requests[requestId].status == RequestStatus.Fulfilled;
    }

    /**
     * @notice Get random number in a specific range
     * @param requestId The fulfilled request ID
     * @param min Minimum value (inclusive)
     * @param max Maximum value (inclusive)
     * @return Random number in range [min, max]
     */
    function getRandomInRange(
        bytes32 requestId,
        uint256 min,
        uint256 max
    ) external view returns (uint256) {
        require(requests[requestId].status == RequestStatus.Fulfilled, "Not fulfilled");
        require(max > min, "Invalid range");

        uint256 randomness = requests[requestId].randomness;
        return min + (randomness % (max - min + 1));
    }
}

/**
 * @title IRandomnessConsumer
 * @notice Interface for contracts that consume randomness
 */
interface IRandomnessConsumer {
    /**
     * @notice Callback when randomness is ready
     * @param requestId The request ID
     * @param randomness The quantum random number
     */
    function handleRandomness(bytes32 requestId, uint256 randomness) external;
}

================
File: contracts/oracles/ZKProofOracle.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "../DilithiumVerifier.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title ZKProofOracle
 * @notice On-chain oracle for off-chain ZK-SNARK proof generation (Dilithium signatures)
 * @dev Similar to Chainlink VRF but for ZK proof generation
 *
 * Usage Flow:
 * 1. Consumer contract calls requestProof() with payment
 * 2. Oracle operator listens for ProofRequested event
 * 3. Operator generates proof off-chain via Vercel API
 * 4. Operator submits proof via fulfillProof()
 * 5. Proof is verified on-chain using Groth16Verifier
 * 6. Consumer's callback is triggered with verified proof
 */
contract ZKProofOracle is Ownable, ReentrancyGuard, Pausable {
    // ============ State Variables ============

    Groth16Verifier public immutable verifier;

    /// @notice Fee per proof request (in wei)
    uint256 public proofFee = 0.001 ether;

    /// @notice Minimum confirmations before fulfilling (for multi-operator future)
    uint256 public requiredConfirmations = 1;

    /// @notice Oracle operators authorized to fulfill proofs
    mapping(address => bool) public operators;

    /// @notice Request tracking
    mapping(bytes32 => ProofRequest) public requests;

    /// @notice Subscription balances (prepaid model)
    mapping(address => uint256) public subscriptions;

    /// @notice Whitelisted addresses that can use oracle for free
    mapping(address => bool) public freeUsers;

    /// @notice Used request IDs for replay protection
    mapping(bytes32 => bool) public usedRequestIds;

    /// @notice Request expiration time (default 1 hour)
    uint256 public requestExpiration = 1 hours;

    /// @notice Revenue collected
    uint256 public totalRevenue;

    // ============ Structs & Enums ============

    enum ProofStatus {
        Pending,
        Fulfilled,
        Failed
    }

    struct ProofRequest {
        address requester;
        bytes32 messageHash;
        bytes32 publicKeyHash;
        bytes message;
        bytes signature;
        bytes publicKey;
        uint256 timestamp;
        ProofStatus status;
        bytes proof;
        uint256[3] publicSignals;
    }

    // ============ Events ============

    event ProofRequested(
        bytes32 indexed requestId,
        address indexed requester,
        bytes32 messageHash,
        bytes32 publicKeyHash
    );

    event ProofFulfilled(
        bytes32 indexed requestId,
        address indexed requester,
        bytes proof,
        uint256[3] publicSignals
    );

    event ProofFailed(bytes32 indexed requestId, string reason);

    event OperatorAdded(address indexed operator);
    event OperatorRemoved(address indexed operator);
    event FeeUpdated(uint256 oldFee, uint256 newFee);
    event SubscriptionDeposit(address indexed subscriber, uint256 amount);
    event SubscriptionWithdrawal(address indexed subscriber, uint256 amount);
    event FreeUserAdded(address indexed user);
    event FreeUserRemoved(address indexed user);

    // ============ Errors ============

    error InsufficientPayment();
    error InvalidRequest();
    error UnauthorizedOperator();
    error ProofVerificationFailed();
    error InvalidProofStatus();
    error InsufficientSubscription();

    // ============ Constructor ============

    constructor(address _verifier) Ownable(msg.sender) {
        verifier = Groth16Verifier(_verifier);
        operators[msg.sender] = true;
    }

    // ============ Core Functions ============

    /**
     * @notice Request a ZK proof for a Dilithium signature (pay-per-use)
     * @param message The message that was signed
     * @param signature The Dilithium signature bytes
     * @param publicKey The Dilithium public key bytes
     * @return requestId Unique identifier for this proof request
     */
    function requestProof(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) external payable nonReentrant whenNotPaused returns (bytes32 requestId) {
        // Check if user is whitelisted for free usage
        if (!freeUsers[msg.sender]) {
            if (msg.value < proofFee) revert InsufficientPayment();
            totalRevenue += proofFee;
        }

        requestId = keccak256(
            abi.encodePacked(
                msg.sender,
                block.timestamp,
                block.number,
                message,
                signature
            )
        );

        if (requests[requestId].timestamp != 0) revert InvalidRequest();

        requests[requestId] = ProofRequest({
            requester: msg.sender,
            messageHash: keccak256(message),
            publicKeyHash: keccak256(publicKey),
            message: message,
            signature: signature,
            publicKey: publicKey,
            timestamp: block.timestamp,
            status: ProofStatus.Pending,
            proof: "",
            publicSignals: [uint256(0), uint256(0), uint256(0)]
        });

        emit ProofRequested(
            requestId,
            msg.sender,
            keccak256(message),
            keccak256(publicKey)
        );

        // Refund excess payment
        if (msg.value > proofFee) {
            payable(msg.sender).transfer(msg.value - proofFee);
        }

        return requestId;
    }

    /**
     * @notice Request proof using prepaid subscription balance
     * @param message The message that was signed
     * @param signature The Dilithium signature bytes
     * @param publicKey The Dilithium public key bytes
     * @return requestId Unique identifier for this proof request
     */
    function requestProofWithSubscription(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) external nonReentrant whenNotPaused returns (bytes32 requestId) {
        if (subscriptions[msg.sender] < proofFee) revert InsufficientSubscription();

        subscriptions[msg.sender] -= proofFee;
        totalRevenue += proofFee;

        requestId = keccak256(
            abi.encodePacked(
                msg.sender,
                block.timestamp,
                block.number,
                message,
                signature
            )
        );

        requests[requestId] = ProofRequest({
            requester: msg.sender,
            messageHash: keccak256(message),
            publicKeyHash: keccak256(publicKey),
            message: message,
            signature: signature,
            publicKey: publicKey,
            timestamp: block.timestamp,
            status: ProofStatus.Pending,
            proof: "",
            publicSignals: [uint256(0), uint256(0), uint256(0)]
        });

        emit ProofRequested(
            requestId,
            msg.sender,
            keccak256(message),
            keccak256(publicKey)
        );

        return requestId;
    }

    /**
     * @notice Fulfill a proof request (called by oracle operator)
     * @param requestId The request ID to fulfill
     * @param _pA Proof point A
     * @param _pB Proof point B
     * @param _pC Proof point C
     * @param _pubSignals Public signals [message_hash, public_key_hash, is_valid]
     */
    function fulfillProof(
        bytes32 requestId,
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[3] calldata _pubSignals
    ) external nonReentrant {
        if (!operators[msg.sender]) revert UnauthorizedOperator();

        ProofRequest storage request = requests[requestId];
        if (request.status != ProofStatus.Pending) revert InvalidProofStatus();

        // Replay protection
        require(!usedRequestIds[requestId], "Request already fulfilled");

        // Expiration check
        require(
            block.timestamp < request.timestamp + requestExpiration,
            "Request expired"
        );

        usedRequestIds[requestId] = true;

        // Verify the proof on-chain
        bool valid = verifier.verifyProof(_pA, _pB, _pC, _pubSignals);
        if (!valid) revert ProofVerificationFailed();

        // Encode proof for storage
        bytes memory proofBytes = abi.encode(_pA, _pB, _pC);

        request.proof = proofBytes;
        request.publicSignals = _pubSignals;
        request.status = ProofStatus.Fulfilled;

        emit ProofFulfilled(requestId, request.requester, proofBytes, _pubSignals);

        // Callback to consumer contract (if it implements the interface)
        try IProofConsumer(request.requester).handleProof(requestId, proofBytes, _pubSignals) {
            // Success
        } catch {
            // Consumer doesn't implement callback, that's ok
        }
    }

    /**
     * @notice Mark a proof request as failed
     * @param requestId The request ID to mark as failed
     * @param reason Why the proof generation failed
     */
    function markProofFailed(bytes32 requestId, string calldata reason) external {
        if (!operators[msg.sender]) revert UnauthorizedOperator();

        ProofRequest storage request = requests[requestId];
        if (request.status != ProofStatus.Pending) revert InvalidProofStatus();

        request.status = ProofStatus.Failed;

        emit ProofFailed(requestId, reason);

        // Refund the fee to requester
        payable(request.requester).transfer(proofFee);
    }

    // ============ Subscription Management ============

    /**
     * @notice Deposit funds for subscription-based usage
     */
    function subscribe() external payable {
        subscriptions[msg.sender] += msg.value;
        emit SubscriptionDeposit(msg.sender, msg.value);
    }

    /**
     * @notice Withdraw unused subscription balance
     * @param amount Amount to withdraw
     */
    function withdrawSubscription(uint256 amount) external nonReentrant {
        if (subscriptions[msg.sender] < amount) revert InsufficientSubscription();

        subscriptions[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);

        emit SubscriptionWithdrawal(msg.sender, amount);
    }

    // ============ Admin Functions ============

    /**
     * @notice Add an oracle operator
     * @param operator Address to authorize
     */
    function addOperator(address operator) external onlyOwner {
        operators[operator] = true;
        emit OperatorAdded(operator);
    }

    /**
     * @notice Remove an oracle operator
     * @param operator Address to remove
     */
    function removeOperator(address operator) external onlyOwner {
        operators[operator] = false;
        emit OperatorRemoved(operator);
    }

    /**
     * @notice Update the proof fee
     * @param newFee New fee in wei
     */
    function setProofFee(uint256 newFee) external onlyOwner {
        require(newFee <= 1 ether, "Fee too high"); // Max 1 ETH
        uint256 oldFee = proofFee;
        proofFee = newFee;
        emit FeeUpdated(oldFee, newFee);
    }

    /**
     * @notice Update request expiration time
     * @param newExpiration New expiration in seconds
     */
    function setRequestExpiration(uint256 newExpiration) external onlyOwner {
        require(newExpiration >= 5 minutes, "Expiration too short");
        require(newExpiration <= 24 hours, "Expiration too long");
        requestExpiration = newExpiration;
    }

    /**
     * @notice Add a user to the free usage whitelist (e.g., your own apps)
     * @param user Address to whitelist
     */
    function addFreeUser(address user) external onlyOwner {
        freeUsers[user] = true;
        emit FreeUserAdded(user);
    }

    /**
     * @notice Remove a user from the free usage whitelist
     * @param user Address to remove
     */
    function removeFreeUser(address user) external onlyOwner {
        freeUsers[user] = false;
        emit FreeUserRemoved(user);
    }

    /**
     * @notice Withdraw collected revenue
     * @param amount Amount to withdraw
     */
    function withdrawRevenue(uint256 amount) external onlyOwner {
        require(amount <= totalRevenue, "Insufficient revenue");
        totalRevenue -= amount;
        payable(owner()).transfer(amount);
    }

    /**
     * @notice Pause the oracle in case of emergency
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @notice Unpause the oracle
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    // ============ View Functions ============

    /**
     * @notice Get request details
     * @param requestId The request ID
     * @return request The full request struct
     */
    function getRequest(bytes32 requestId) external view returns (ProofRequest memory) {
        return requests[requestId];
    }

    /**
     * @notice Check if a request is fulfilled
     * @param requestId The request ID
     * @return fulfilled True if fulfilled
     */
    function isRequestFulfilled(bytes32 requestId) external view returns (bool) {
        return requests[requestId].status == ProofStatus.Fulfilled;
    }
}

/**
 * @title IProofConsumer
 * @notice Interface for contracts that consume ZK proofs
 */
interface IProofConsumer {
    /**
     * @notice Callback function called when proof is ready
     * @param requestId The request ID
     * @param proof The serialized proof
     * @param publicSignals The public signals [message_hash, pk_hash, is_valid]
     */
    function handleProof(
        bytes32 requestId,
        bytes memory proof,
        uint256[3] memory publicSignals
    ) external;
}

================
File: contracts/vault/PQVault4626.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {ERC4626} from "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC4626.sol";
import {ERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import {IERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
import {ReentrancyGuard} from "lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol";
import {Pausable} from "lib/openzeppelin-contracts/contracts/utils/Pausable.sol";
import {Ownable} from "lib/openzeppelin-contracts/contracts/access/Ownable.sol";

/// @title PQVault4626
/// @notice ERC-4626 tokenized vault with vesting schedules for PQ wallets
/// @dev Extends OpenZeppelin's ERC4626 with time-locked vesting functionality
contract PQVault4626 is ERC4626, ReentrancyGuard, Pausable, Ownable {
    using SafeERC20 for IERC20;

    /// @notice Vesting schedule for a depositor
    /// @dev Using block numbers instead of timestamps to prevent miner manipulation
    struct VestingSchedule {
        uint128 totalShares;        // Total shares vested
        uint128 withdrawnShares;    // Shares already withdrawn
        uint64 cliffBlock;          // Cliff period end (block number)
        uint64 vestingEndBlock;     // Full vesting end (block number)
        uint64 startBlock;          // Vesting start (block number)
        bool active;                // Is vesting active
    }

    /// @notice Average block time in seconds (12 seconds for Ethereum mainnet)
    uint256 public constant BLOCK_TIME = 12;

    /// @notice Mapping of user address to their vesting schedule
    mapping(address => VestingSchedule) public vestingSchedules;

    /// @notice Emitted when user deposits with vesting
    event DepositWithVesting(
        address indexed user,
        uint256 assets,
        uint256 shares,
        uint256 vestingDuration,
        uint256 cliffDuration
    );

    /// @notice Emitted when user withdraws vested shares
    event WithdrawVested(
        address indexed user,
        uint256 shares,
        uint256 assets
    );

    /// @notice Constructor
    /// @param asset_ The underlying ERC20 asset
    /// @param name_ The name of the vault token
    /// @param symbol_ The symbol of the vault token
    constructor(
        IERC20 asset_,
        string memory name_,
        string memory symbol_
    ) ERC4626(asset_) ERC20(name_, symbol_) Ownable(msg.sender) {}

    /// @notice Deposit assets with a vesting schedule
    /// @param assets Amount of assets to deposit
    /// @param receiver Address receiving the shares
    /// @param vestingDuration Total vesting duration in seconds
    /// @param cliffDuration Cliff period in seconds
    /// @return shares Amount of shares minted
    function depositWithVesting(
        uint256 assets,
        address receiver,
        uint256 vestingDuration,
        uint256 cliffDuration
    ) external virtual nonReentrant whenNotPaused returns (uint256 shares) {
        require(assets > 0, "Cannot deposit 0");
        require(receiver != address(0), "Invalid receiver");
        require(vestingDuration > 0, "Invalid vesting duration");
        require(vestingDuration <= 10 * 365 days, "Vesting too long"); // Max 10 years
        require(cliffDuration <= vestingDuration, "Cliff exceeds vesting");
        require(!vestingSchedules[receiver].active, "Vesting already active");

        // Convert time durations to block counts (more manipulation-resistant)
        uint256 vestingBlocks = vestingDuration / BLOCK_TIME;
        uint256 cliffBlocks = cliffDuration / BLOCK_TIME;

        // Prevent overflow in block number calculations
        require(block.number + vestingBlocks < type(uint64).max, "Block number overflow");

        // Calculate shares
        shares = previewDeposit(assets);
        require(shares > 0, "Zero shares");
        require(shares <= type(uint128).max, "Shares overflow"); // Prevent overflow in VestingSchedule

        // Transfer assets from sender
        SafeERC20.safeTransferFrom(IERC20(asset()), msg.sender, address(this), assets);

        // Mint shares to this contract (held until vested)
        _mint(address(this), shares);

        // Create vesting schedule using block numbers
        uint64 startBlock = uint64(block.number);
        vestingSchedules[receiver] = VestingSchedule({
            totalShares: uint128(shares),
            withdrawnShares: 0,
            cliffBlock: startBlock + uint64(cliffBlocks),
            vestingEndBlock: startBlock + uint64(vestingBlocks),
            startBlock: startBlock,
            active: true
        });

        emit DepositWithVesting(receiver, assets, shares, vestingDuration, cliffDuration);
        emit Deposit(msg.sender, receiver, assets, shares);

        return shares;
    }

    /// @notice Withdraw vested shares
    /// @param shares Amount of shares to withdraw
    /// @return assets Amount of assets received
    function withdrawVested(uint256 shares) external nonReentrant returns (uint256 assets) {
        require(shares > 0, "Cannot withdraw 0");

        VestingSchedule storage schedule = vestingSchedules[msg.sender];
        require(schedule.active, "No active vesting");

        uint256 vestedShares = _calculateVestedShares(msg.sender);
        require(vestedShares > schedule.withdrawnShares, "No vested shares available");

        uint256 withdrawableShares = vestedShares - schedule.withdrawnShares;
        require(shares <= withdrawableShares, "Insufficient vested shares");

        // Update withdrawn shares
        schedule.withdrawnShares += uint128(shares);

        // Transfer shares from vault to user
        _transfer(address(this), msg.sender, shares);

        // Redeem shares for assets
        assets = redeem(shares, msg.sender, msg.sender);

        // If all shares withdrawn and fully vested, deactivate schedule
        if (schedule.withdrawnShares >= schedule.totalShares) {
            schedule.active = false;
        }

        emit WithdrawVested(msg.sender, shares, assets);

        return assets;
    }

    /// @notice Get vesting information for a user
    /// @param user The user address
    /// @return totalShares Total shares in vesting
    /// @return vestedShares Currently vested shares
    /// @return withdrawnShares Already withdrawn shares
    /// @return cliffBlock Cliff end block number
    /// @return vestingEndBlock Full vesting end block number
    function getVestingInfo(address user)
        external
        view
        returns (
            uint256 totalShares,
            uint256 vestedShares,
            uint256 withdrawnShares,
            uint256 cliffBlock,
            uint256 vestingEndBlock
        )
    {
        VestingSchedule memory schedule = vestingSchedules[user];
        return (
            schedule.totalShares,
            _calculateVestedShares(user),
            schedule.withdrawnShares,
            schedule.cliffBlock,
            schedule.vestingEndBlock
        );
    }

    /// @notice Calculate vested shares for a user
    /// @param user The user address
    /// @return Amount of vested shares
    /// @dev Uses block numbers instead of timestamps to prevent miner manipulation
    function _calculateVestedShares(address user) internal view returns (uint256) {
        VestingSchedule memory schedule = vestingSchedules[user];

        if (!schedule.active) {
            return 0;
        }

        // Before cliff block, nothing is vested
        if (block.number < schedule.cliffBlock) {
            return 0;
        }

        // After vesting end block, everything is vested
        if (block.number >= schedule.vestingEndBlock) {
            return schedule.totalShares;
        }

        // Linear vesting between cliff and end (by block number)
        uint256 vestingBlocks = schedule.vestingEndBlock - schedule.cliffBlock;
        uint256 blocksVested = block.number - schedule.cliffBlock;

        return (uint256(schedule.totalShares) * blocksVested) / vestingBlocks;
    }

    /// @notice Emergency pause
    function pause() external onlyOwner {
        _pause();
    }

    /// @notice Unpause
    function unpause() external onlyOwner {
        _unpause();
    }

    /// @notice Override deposit to add pause check
    function deposit(uint256 assets, address receiver)
        public
        override
        whenNotPaused
        returns (uint256)
    {
        return super.deposit(assets, receiver);
    }

    /// @notice Override mint to add pause check
    function mint(uint256 shares, address receiver)
        public
        override
        whenNotPaused
        returns (uint256)
    {
        return super.mint(shares, receiver);
    }
}

================
File: test/DilithiumVerifier.t.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Test, console} from "forge-std/Test.sol";
import {DilithiumVerifier} from "../contracts/libraries/DilithiumVerifier.sol";

/// @title DilithiumVerifierTest
/// @notice Unit tests for Dilithium signature verification
contract DilithiumVerifierTest is Test {
    // Test vectors from NIST PQC submission
    // These would normally come from the reference implementation

    bytes public validPublicKey;
    bytes public validSignature;
    bytes public testMessage;

    function setUp() public {
        // Create test data with correct sizes
        // Public key: 1952 bytes (SEEDBYTES + K * POLYT1_PACKEDBYTES)
        validPublicKey = new bytes(1952);

        // Signature: 3293 bytes (SEEDBYTES + L * POLYZ_PACKEDBYTES + OMEGA + K)
        validSignature = new bytes(3293);

        // Test message
        testMessage = "Hello, Post-Quantum World!";

        // Fill with deterministic test data
        for (uint256 i = 0; i < validPublicKey.length; i++) {
            validPublicKey[i] = bytes1(uint8(i % 256));
        }

        for (uint256 i = 0; i < validSignature.length; i++) {
            validSignature[i] = bytes1(uint8((i * 7 + 13) % 256));
        }
    }

    function test_GetParameters() public pure {
        string memory params = DilithiumVerifier.getParameters();
        console.log("Dilithium3 Parameters:", params);
        assertTrue(bytes(params).length > 0);
    }

    function test_GetSignatureSize() public pure {
        uint256 size = DilithiumVerifier.getSignatureSize();
        assertEq(size, 3293, "Signature size should be 3293 bytes");
    }

    function test_GetPublicKeySize() public pure {
        uint256 size = DilithiumVerifier.getPublicKeySize();
        assertEq(size, 1952, "Public key size should be 1952 bytes");
    }

    function test_VerifyValidSignature() public view {
        bool result = DilithiumVerifier.verify(testMessage, validSignature, validPublicKey);
        assertTrue(result, "Valid signature should verify");
    }

    function test_RevertInvalidSignatureLength() public {
        bytes memory invalidSig = new bytes(100); // Too short

        vm.expectRevert(DilithiumVerifier.InvalidSignatureLength.selector);
        this.externalVerify(testMessage, invalidSig, validPublicKey);
    }

    function test_RevertInvalidPublicKeyLength() public {
        bytes memory invalidPk = new bytes(100); // Too short

        vm.expectRevert(DilithiumVerifier.InvalidPublicKeyLength.selector);
        this.externalVerify(testMessage, validSignature, invalidPk);
    }

    function test_RevertEmptyMessage() public {
        bytes memory emptyMsg = "";

        vm.expectRevert(DilithiumVerifier.InvalidMessageLength.selector);
        this.externalVerify(emptyMsg, validSignature, validPublicKey);
    }

    function test_DifferentMessages() public view {
        bytes memory msg1 = "Message 1";
        bytes memory msg2 = "Message 2";

        // Simplified implementation passes basic structural checks
        // Both messages should verify with the placeholder implementation
        bool result1 = DilithiumVerifier.verify(msg1, validSignature, validPublicKey);
        bool result2 = DilithiumVerifier.verify(msg2, validSignature, validPublicKey);

        // Placeholder implementation checks structure, not cryptographic validity
        assertTrue(result1, "Message 1 should verify in placeholder mode");
        assertTrue(result2, "Message 2 should verify in placeholder mode");
    }

    function test_GasConsumption() public view {
        uint256 gasBefore = gasleft();
        DilithiumVerifier.verify(testMessage, validSignature, validPublicKey);
        uint256 gasUsed = gasBefore - gasleft();

        console.log("Gas used for Dilithium verification:", gasUsed);
        // Log for analysis - full implementation will be much higher
    }

    function test_MultipleVerifications() public view {
        // Test multiple verifications with same key
        // Placeholder implementation verifies structure, not cryptography
        for (uint256 i = 0; i < 5; i++) {
            bytes memory message = abi.encodePacked("Message ", i);
            bool result = DilithiumVerifier.verify(message, validSignature, validPublicKey);
            assertTrue(result, "Placeholder should verify structurally valid signatures");
        }
    }

    function test_FuzzMessage(bytes memory randomMessage) public view {
        // Fuzz test with random messages
        vm.assume(randomMessage.length > 0);
        vm.assume(randomMessage.length < 10000);

        bool result = DilithiumVerifier.verify(randomMessage, validSignature, validPublicKey);
        // Should not revert, but may or may not verify
        assertTrue(result || !result); // Always true, just testing no revert
    }

    function test_FuzzSignature(bytes memory randomSig) public view {
        // Fuzz test with random signatures
        vm.assume(randomSig.length == 3293); // Must be correct length

        // Some signatures might fail internal checks, so we test both paths
        bool shouldPass = true;
        try this.externalVerify(testMessage, randomSig, validPublicKey) returns (bool result) {
            // Should either verify or not verify
            assertTrue(result || !result);
        } catch {
            // Internal checks may revert for invalid signatures
            shouldPass = false;
        }

        // Test passes if either path succeeds
        assertTrue(shouldPass || !shouldPass);
    }

    // External wrapper for try/catch in fuzz test
    function externalVerify(
        bytes memory message,
        bytes memory signature,
        bytes memory publicKey
    ) external pure returns (bool) {
        return DilithiumVerifier.verify(message, signature, publicKey);
    }
}





================================================================
End of Codebase
================================================================
