# Understanding Circom Circuit Compilation

## What Does "Compile Circom Circuits" Mean?

Think of Circom circuits like compiling a regular program, but for **math proofs**.

### Simple Analogy

**Regular Programming:**
```
Source Code (.ts) → Compiler → Binary Executable (.exe)
TypeScript       → tsc      → JavaScript
```

**ZK-SNARK Programming:**
```
Circuit Code (.circom) → Compiler → Proof Generator (.wasm + .zkey)
Circom Circuit        → circom   → Files that generate proofs
```

## Your Current Situation

### What You Have Now

```
zk-dilithium/
├── circuits/
│   └── dilithium_simple.circom   ← Source code (written) ✅
├── api/
│   └── prove.js                  ← API endpoint (written) ✅
└── scripts/
    ├── setup.js                  ← Setup script (written) ✅
    └── prove.js                  ← Test script (written) ✅
```

### What You DON'T Have Yet

```
zk-dilithium/
└── build/
    ├── dilithium_simple.wasm      ← Proof generator (binary) ❌
    ├── dilithium_simple.zkey      ← Proving key (cryptographic) ❌
    ├── verification_key.json      ← Verification key ❌
    └── powersOfTau28_hez_final_14.ptau  ← Trusted setup file ❌
```

## Why Is It Computationally Expensive?

### Step 1: Compile Circuit (Moderate)

```bash
circom circuits/dilithium_simple.circom --r1cs --wasm
```

**What it does:**
- Converts your Circom code into a mathematical constraint system
- Creates ~5,000 constraints (equations) for the simple circuit
- Outputs: `.r1cs` (constraint system) and `.wasm` (witness generator)

**Resources:**
- Time: ~30 seconds
- CPU: High
- RAM: ~2GB
- Disk: ~50MB output

### Step 2: Download Powers of Tau (One-time)

```bash
wget https://hermez.s3-eu-west-1.amazonaws.com/powersOfTau28_hez_final_14.ptau
```

**What it is:**
- A **trusted setup ceremony** result
- Contains cryptographic parameters for proving
- Generated by 1000+ participants to ensure no backdoors
- Size: **~200MB file**

**Resources:**
- Time: ~2 minutes (download)
- Network: 200MB bandwidth

### Step 3: Generate Proving Key (VERY EXPENSIVE)

```bash
snarkjs groth16 setup dilithium_simple.r1cs powersOfTau28_hez_final_14.ptau circuit.zkey
```

**What it does:**
- Combines your circuit with the trusted setup
- Creates a **proving key** (.zkey file)
- This is the **MOST expensive** step

**Resources:**
- Time: **5-20 minutes** (depends on circuit size)
- CPU: **100% usage** (multi-core)
- RAM: **4-8GB**
- Disk: ~100MB output

### Step 4: Export Verification Key (Fast)

```bash
snarkjs zkey export verificationkey circuit.zkey verification_key.json
```

**Resources:**
- Time: ~5 seconds
- CPU: Low
- Output: Small JSON file

## Two-Tier Approach: Simple vs Full

### Simple Circuit (Current)

**Purpose:** Testing & development

```circom
template SimpleDilithiumVerifier() {
    var SIG_SIZE = 32;      // Simplified
    var PK_SIZE = 16;       // Simplified

    // Just hash checks, not real Dilithium
}

Constraints: ~5,000
```

**Compilation Time:**
- Circuit compile: ~30 seconds
- Key generation: **~5 minutes**
- Proof generation: **~500ms per proof**
- **Total setup: ~6 minutes**

### Full Circuit (Production)

**Purpose:** Real Dilithium verification

```circom
template FullDilithiumVerifier() {
    var SIG_SIZE = 26344;   // Full 3293 bytes
    var PK_SIZE = 15616;    // Full 1952 bytes

    // Full Dilithium3 algorithm
}

Constraints: ~2-3 million
```

**Compilation Time:**
- Circuit compile: **~5 minutes**
- Key generation: **~2-4 hours** (!)
- Proof generation: **~5-10 seconds per proof**
- **Total setup: ~2-4 hours**

## Why Deploy with Mock Data First?

### Strategy: Phased Deployment

#### Phase 1: Mock Proofs (NOW - 5 minutes)
```bash
./deploy-vercel.sh
```

**Deploys:**
- `/api/prove` endpoint → Returns fake proofs ✅
- Frontend integration ✅
- Testing workflows ✅

**Benefits:**
- Dashboard works immediately
- Test UI/UX
- Verify integration
- No waiting for compilation

#### Phase 2: Simple Circuit (Later - 6 minutes)
```bash
cd zk-dilithium
./quick_setup.sh
```

**Deploys:**
- Real proofs for simplified Dilithium ✅
- Verifies basic ZK infrastructure ✅
- Gas savings measurable ✅

**Compilation:**
- Run on local machine or cloud VM
- 5-6 minutes total
- Upload .wasm and .zkey files to Vercel

#### Phase 3: Full Circuit (Production - Hours)
```bash
cd zk-dilithium
npm run build:full
```

**Deploys:**
- Real Dilithium3 verification ✅
- Production-ready ✅
- Maximum gas savings ✅

**Compilation:**
- Requires beefy machine (8GB+ RAM)
- **2-4 hours** to compile
- Upload larger files to Vercel

## Current API Behavior

### What `api/prove.js` Does Now

```javascript
// Lines 122-127 in api/prove.js

// MOCK: In production, this would call snarkjs
// const { proof, publicSignals } = await snarkjs.groth16.fullProve(
//   input,
//   '/var/task/circuits/dilithium_simple.wasm',
//   '/var/task/keys/dilithium_simple.zkey'
// );

// Mock proof for now (replace with actual snarkjs call after setup)
const mockProof = {
  pi_a: ['0x1234', '0x5678', '0x9abc'],
  pi_b: [['0xdef0', '0x1111'], ['0x2222', '0x3333']],
  pi_c: ['0x4444', '0x5555'],
  protocol: 'groth16',
  curve: 'bn128'
};
```

**Returns:** Fake proof immediately (no computation)

### What It Will Do After Compilation

```javascript
// After you compile and upload .wasm + .zkey files

const { proof, publicSignals } = await snarkjs.groth16.fullProve(
  input,
  '/var/task/circuits/dilithium_simple.wasm',      // ← Need to upload
  '/var/task/keys/dilithium_simple.zkey'           // ← Need to upload
);

// Real proof (takes ~500ms to compute)
```

**Returns:** Real cryptographic proof

## How to Compile (When Ready)

### Option 1: Local Machine (Recommended)

```bash
# 1. Go to zk-dilithium directory
cd zk-dilithium

# 2. Install dependencies
npm install

# 3. Install Circom compiler
# macOS:
brew install circom

# Linux:
curl -sSfL https://github.com/iden3/circom/releases/download/v2.1.6/circom-linux-amd64 -o /usr/local/bin/circom
chmod +x /usr/local/bin/circom

# 4. Run setup script (6 minutes)
./quick_setup.sh

# 5. Upload to Vercel
# Copy build/dilithium_simple_js/dilithium_simple.wasm to Vercel
# Copy build/dilithium_simple.zkey to Vercel
# (Can use Vercel Blob Storage or include in deployment)

# 6. Update api/prove.js to uncomment real snarkjs call
```

### Option 2: Cloud VM (For Large Circuits)

```bash
# 1. Launch EC2 instance (t3.large - 8GB RAM)
# 2. Clone repo
git clone https://github.com/your-repo/EthVaultPQ.git
cd EthVaultPQ/zk-dilithium

# 3. Install dependencies
npm install
sudo apt install circom

# 4. Run setup
./quick_setup.sh

# 5. Download compiled files
scp user@ec2:~/EthVaultPQ/zk-dilithium/build/* ./local-build/

# 6. Upload to Vercel
```

## File Sizes Reference

| File | Size | Purpose |
|------|------|---------|
| `dilithium_simple.circom` | 2KB | Source code ✅ |
| `dilithium_simple.wasm` | ~5MB | Witness generator (after compile) |
| `dilithium_simple.zkey` | ~50MB | Proving key (after setup) |
| `verification_key.json` | 1KB | Verification key |
| `powersOfTau28_hez_final_14.ptau` | 200MB | Trusted setup (one-time download) |

## Vercel Deployment Options

### Option A: Include Files in Deployment

```
zk-dilithium/
├── public/
│   ├── circuits/
│   │   └── dilithium_simple.wasm     (5MB)
│   └── keys/
│       └── dilithium_simple.zkey     (50MB)
└── api/
    └── prove.js
```

**Pros:** Simple
**Cons:** Slow deployments (55MB upload each time)

### Option B: Vercel Blob Storage (Recommended)

```javascript
// Upload once to Blob Storage
import { put } from '@vercel/blob';

await put('circuits/dilithium_simple.wasm', wasmFile, { access: 'public' });
await put('keys/dilithium_simple.zkey', zkeyFile, { access: 'public' });

// Then download in api/prove.js
const wasmUrl = 'https://your-blob.vercel-storage.com/circuits/dilithium_simple.wasm';
```

**Pros:** Fast deployments, CDN distribution
**Cons:** Small storage cost (~$0.01/month for 55MB)

## Summary

### "Compile Circom Circuits" Means:

1. **Convert** Circom source code → Binary proof generator
2. **Generate** cryptographic keys (proving + verification)
3. **Requires** ~6 minutes for simple, ~2-4 hours for full circuit
4. **Outputs** Large files (.wasm + .zkey) that need to be deployed
5. **Only do once** - then reuse for all proofs

### Current State:

✅ **Source code written** - circuits, API, scripts all ready
❌ **Not compiled yet** - using mock proofs for now
✅ **Can deploy immediately** - frontend works with mocks
⏳ **Compile later** - when ready for real proofs

### Recommended Flow:

1. **Now**: Deploy with mock proofs → Test integration (5 min)
2. **Soon**: Compile simple circuit → Get real proofs (6 min)
3. **Later**: Compile full circuit → Production ready (2-4 hrs)

## Questions?

**Q: Can I skip compilation?**
A: Yes! Deploy with mocks, test everything, compile later.

**Q: Do I need to compile every time?**
A: No! Compile once, reuse files forever (unless circuit changes).

**Q: Can I compile on my laptop?**
A: Simple circuit: Yes (6 min). Full circuit: Need 8GB+ RAM.

**Q: What if I don't want ZK proofs?**
A: Use `ON_CHAIN` mode - direct Dilithium verification (no compilation needed).

**Q: Are mock proofs secure?**
A: No! Only for development. Production must use real proofs or on-chain mode.
