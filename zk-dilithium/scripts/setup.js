#!/usr/bin/env node

/**
 * Setup script for ZK-SNARK Dilithium verifier
 *
 * Steps:
 * 1. Compile the Circom circuit
 * 2. Generate proving and verification keys using Groth16
 * 3. Export Solidity verifier contract
 *
 * Run: node scripts/setup.js
 */

const snarkjs = require('snarkjs');
const fs = require('fs');
const path = require('path');

const CIRCUIT_NAME = 'dilithium_simple';
const PTAU_PATH = 'powersOfTau28_hez_final_14.ptau'; // For circuits up to 2^14 constraints

async function setup() {
    console.log('🔧 Starting ZK-SNARK setup for Dilithium verifier...\n');

    const buildDir = path.join(__dirname, '..', 'build');
    const circuitWasm = path.join(buildDir, `${CIRCUIT_NAME}_js`, `${CIRCUIT_NAME}.wasm`);
    const circuitR1cs = path.join(buildDir, `${CIRCUIT_NAME}.r1cs`);
    const zkeyPath = path.join(buildDir, `${CIRCUIT_NAME}.zkey`);
    const vkeyPath = path.join(buildDir, 'verification_key.json');
    const verifierPath = path.join(__dirname, '..', '..', 'contracts', 'zk', 'DilithiumZKVerifier.sol');

    // Create build directory
    if (!fs.existsSync(buildDir)) {
        fs.mkdirSync(buildDir, { recursive: true });
    }

    try {
        // Step 1: Download powers of tau if not exists
        console.log('📥 Step 1: Checking powers of tau...');
        const ptauFullPath = path.join(buildDir, PTAU_PATH);
        if (!fs.existsSync(ptauFullPath)) {
            console.log('   Downloading powers of tau (this may take a few minutes)...');
            console.log(`   Run: wget https://hermez.s3-eu-west-1.amazonaws.com/${PTAU_PATH}`);
            console.log('   Or download manually and place in build/ directory');
            console.log('   Skipping for now - using local if available\n');
        } else {
            console.log('   ✅ Powers of tau found\n');
        }

        // Step 2: Setup proving key (Groth16)
        console.log('🔑 Step 2: Generating proving key (Groth16)...');
        if (fs.existsSync(circuitR1cs) && fs.existsSync(ptauFullPath)) {
            await snarkjs.zKey.newZKey(circuitR1cs, ptauFullPath, zkeyPath);
            console.log('   ✅ Proving key generated\n');

            // Step 3: Export verification key
            console.log('🔑 Step 3: Exporting verification key...');
            const vKey = await snarkjs.zKey.exportVerificationKey(zkeyPath);
            fs.writeFileSync(vkeyPath, JSON.stringify(vKey, null, 2));
            console.log('   ✅ Verification key exported\n');

            // Step 4: Generate Solidity verifier
            console.log('📝 Step 4: Generating Solidity verifier contract...');
            const verifierDir = path.dirname(verifierPath);
            if (!fs.existsSync(verifierDir)) {
                fs.mkdirSync(verifierDir, { recursive: true });
            }

            const verifierCode = await snarkjs.zKey.exportSolidityVerifier(zkeyPath);

            // Customize the verifier contract
            const customVerifier = `// SPDX-License-Identifier: MIT
// Auto-generated by snarkjs
// Modified for EthVaultPQ Dilithium verification

pragma solidity ^0.8.28;

${verifierCode.replace('pragma solidity >=0.7.0 <0.9.0;', '')}

/// @title DilithiumZKVerifier
/// @notice Verifies zero-knowledge proofs of Dilithium signature validity
/// @dev This contract was auto-generated and wrapped for EthVaultPQ
contract DilithiumZKVerifier is Groth16Verifier {
    /// @notice Verify a Dilithium signature via ZK-SNARK
    /// @param proof The Groth16 proof (8 uint256 values)
    /// @param publicSignals Public inputs [message_hash, public_key_hash, is_valid]
    /// @return True if the proof is valid
    function verifyDilithiumProof(
        uint256[8] calldata proof,
        uint256[3] calldata publicSignals
    ) external view returns (bool) {
        // publicSignals[0] = message_hash
        // publicSignals[1] = public_key_hash
        // publicSignals[2] = is_valid (should be 1)

        bool valid = this.verifyProof(
            [proof[0], proof[1]],
            [[proof[2], proof[3]], [proof[4], proof[5]]],
            [proof[6], proof[7]],
            publicSignals
        );

        // Also check that the circuit output is_valid = 1
        return valid && publicSignals[2] == 1;
    }

    /// @notice Get the verification key hash for integrity checks
    function getVKHash() external pure returns (bytes32) {
        // TODO: Compute from actual vkey parameters
        return keccak256(abi.encodePacked("DilithiumZKVerifier", "v1"));
    }
}
`;

            fs.writeFileSync(verifierPath, customVerifier);
            console.log(`   ✅ Solidity verifier saved to: ${verifierPath}\n`);

            console.log('✨ Setup complete!\n');
            console.log('Next steps:');
            console.log('  1. Run: forge build (to compile the Solidity verifier)');
            console.log('  2. Run: node scripts/prove.js (to generate test proofs)');
            console.log('  3. Integrate with PQValidator contract\n');

        } else {
            console.log('⚠️  Missing required files:');
            if (!fs.existsSync(circuitR1cs)) {
                console.log(`   ❌ ${circuitR1cs}`);
                console.log('   Run: circom circuits/${CIRCUIT_NAME}.circom --r1cs --wasm --sym -o build/');
            }
            if (!fs.existsSync(ptauFullPath)) {
                console.log(`   ❌ ${ptauFullPath}`);
                console.log(`   Download from: https://hermez.s3-eu-west-1.amazonaws.com/${PTAU_PATH}`);
            }
            console.log('\n');
        }

    } catch (error) {
        console.error('❌ Error during setup:', error);
        process.exit(1);
    }
}

// Run setup if called directly
if (require.main === module) {
    setup().catch(console.error);
}

module.exports = { setup };
